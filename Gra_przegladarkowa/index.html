<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sanktuarium - Gra RPG</title>

    <!-- PWA & iOS Standalone -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sanktuarium">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#050505">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="img/icon-192.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap');

        * {
            box-sizing: border-box;
        }

        :root {
            --color-bg: #050505;
            --color-border: #3d3d3d;
            --color-accent: #c21e1e;
            --color-gold: #cfaa6e;
            --color-text: #a8a8a8;
        }

        body {
            background-color: var(--color-bg);
            background-image: url('img/locations/tło na podróż.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            color: var(--color-text);
            font-family: 'Cinzel', serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            /* No scrolling in game mode */
            user-select: none;
            /* iOS safe areas */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Rotate phone overlay */
        .rotate-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--color-gold);
            text-align: center;
            padding: 20px;
        }

        .rotate-overlay .rotate-icon {
            font-size: 80px;
            animation: rotatePhone 2s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .rotate-overlay h2 {
            font-size: 1.5rem;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .rotate-overlay p {
            font-size: 1rem;
            color: #888;
            margin: 0;
        }

        @keyframes rotatePhone {

            0%,
            100% {
                transform: rotate(-30deg);
            }

            50% {
                transform: rotate(30deg);
            }
        }

        .rotate-fullscreen-btn {
            margin-top: 30px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.1));
            border: 2px solid var(--color-gold);
            color: var(--color-gold);
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .rotate-fullscreen-btn:hover,
        .rotate-fullscreen-btn:active {
            background: var(--color-gold);
            color: #000;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        .rotate-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        @media screen and (max-width: 900px) and (orientation: portrait) {
            .rotate-overlay {
                display: flex;
            }

            #selectScreen,
            #gameScreen {
                display: none !important;
            }
        }

        /* --- CHARACTER SELECT SCREEN --- */
        #selectScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s;
        }

        #selectScreen.hidden {
            opacity: 0;
            pointer-events: none;
            display: none;
        }

        h1 {
            font-size: 2.5rem;
            color: var(--color-accent);
            text-shadow: 0 0 20px rgba(194, 30, 30, 0.5), 0 5px 10px black;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 5px;
            border-bottom: 2px solid var(--color-border);
            display: inline-block;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 1rem;
            color: var(--color-gold);
            margin-bottom: 30px;
            font-weight: 400;
        }

        .grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            perspective: 1000px;
            max-width: 1000px;
            margin: 0 auto;
            padding-bottom: 100px;
        }

        .card {
            background: linear-gradient(180deg, #1a2a3a 0%, #0d1821 50%, #0a1520 100%);
            border: 1px solid rgba(100, 180, 255, 0.3);
            width: 180px;
            height: 280px;
            position: relative;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(50, 150, 255, 0.2), inset 0 0 30px rgba(100, 180, 255, 0.05);
            border-radius: 8px;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 10px 30px rgba(50, 150, 255, 0.4), inset 0 0 40px rgba(100, 180, 255, 0.1);
            z-index: 10;
        }

        .card.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.6), inset 0 0 20px rgba(0, 212, 255, 0.1);
            transform: scale(1.05);
            z-index: 20;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: var(--color-gold);
            z-index: 10;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .card.selected {
            border-color: var(--color-accent);
            box-shadow: 0 0 20px rgba(194, 30, 30, 0.6);
            transform: scale(1.05);
            z-index: 20;
        }

        .card-image-container {
            width: 100%;
            height: 70%;
            overflow: hidden;
            border-bottom: 1px solid var(--color-border);
        }

        .card-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: top center;
            transition: transform 0.5s ease;
            filter: grayscale(40%) contrast(1.2);
        }

        .card:hover .card-image {
            transform: scale(1.1);
            filter: grayscale(0%) contrast(1.1);
        }

        .card-content {
            padding: 10px;
            height: auto;
            min-height: 60px;
            background: linear-gradient(180deg, #1a1a1a, #111);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 4px;
        }

        .class-name {
            font-size: 0.9rem;
            color: var(--color-gold);
            text-transform: uppercase;
            font-weight: bold;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.2;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .char-attribute {
            font-size: 0.75rem;
            color: #888;
            font-style: italic;
        }

        .card:hover .select-btn {
            background: var(--color-gold);
            color: black;
            font-weight: bold;
        }

        .card.selected .select-btn {
            background: var(--color-accent);
            color: white;
            border-color: red;
        }

        .orb {
            position: fixed;
            bottom: 20px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #800000, #330000);
            border-radius: 50%;
            box-shadow: 0 0 20px var(--color-accent), inset 0 0 15px black;
            border: 3px solid #333;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: white;
            text-shadow: 0 0 5px black;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .orb:hover {
            transform: scale(1.1);
            filter: brightness(1.2);
        }

        .orb-right {
            right: 20px;
            background: linear-gradient(135deg, #22c55e, #16a34a, #15803d);
            box-shadow: 0 0 25px rgba(34, 197, 94, 0.6), inset 0 -5px 15px rgba(0, 0, 0, 0.4);
            visibility: hidden;
            opacity: 0;
            transition: all 0.5s;
            font-weight: bold;
            letter-spacing: 3px;
            font-size: 1.1rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .orb-right:hover {
            transform: scale(1.15);
            box-shadow: 0 0 40px rgba(34, 197, 94, 0.8), inset 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        .orb-right.visible {
            visibility: visible;
            opacity: 1;
            animation: pulseGreen 2s ease-in-out infinite;
        }

        @keyframes pulseGreen {

            0%,
            100% {
                box-shadow: 0 0 25px rgba(34, 197, 94, 0.6), inset 0 -5px 15px rgba(0, 0, 0, 0.4);
            }

            50% {
                box-shadow: 0 0 40px rgba(34, 197, 94, 0.9), inset 0 -5px 15px rgba(0, 0, 0, 0.4);
            }
        }

        /* --- GAME SCREEN (Margonem Style) --- */
        #gameScreen {
            display: none;
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000;
        }

        #gameScreen.active {
            display: block;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr;
            height: 100%;
            width: 100%;
        }

        @media (max-width: 1024px) {
            .game-layout {
                grid-template-columns: 0 1fr 0;
                /* Hide panels on mobile/tablet */
            }

            .panel {
                display: none;
                /* Hide panel content */
            }

            /* Enable map full width */
            .game-map-container {
                grid-column: 1 / -1;
            }
        }

        /* Top Bar */
        .top-bar {
            grid-column: 1 / -1;
            background: #111;
            border-bottom: 2px solid var(--color-border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 33%;
        }

        .player-avatar-mini {
            width: 40px;
            height: 40px;
            border: 2px solid var(--color-gold);
            border-radius: 50%;
            object-fit: cover;
        }

        .player-bars {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bar {
            height: 8px;
            background: #333;
            border: 1px solid #555;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s;
        }

        .hp {
            background: #b30000;
        }

        .mana {
            background: #0044cc;
        }

        .exp {
            background: #d4af37;
            height: 4px;
            margin-top: 2px;
        }

        /* Mobile HUD Styles */
        .hud-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hud-bars {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 80px;
        }

        .hud-bar {
            height: 12px;
            background: #222;
            border: 1px solid #444;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }

        .hud-bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s;
        }

        .hud-bar.hp .hud-bar-fill {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
        }

        .hud-bar.mana .hud-bar-fill {
            background: linear-gradient(to bottom, #4488ff, #0044cc);
        }

        .hud-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8px;
            color: white;
            text-shadow: 0 1px 2px black;
            font-weight: bold;
        }

        .hud-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .hud-center #hudName {
            font-size: 11px;
            color: var(--color-gold);
            font-weight: bold;
            letter-spacing: 1px;
        }

        .hud-level {
            font-size: 9px;
            color: #888;
        }

        .hud-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hud-gold {
            font-size: 12px;
            color: #ffd700;
        }

        .hud-menu-btn {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }

        .player-avatar-mini {
            width: 32px;
            height: 32px;
            border: 2px solid var(--color-gold);
            border-radius: 50%;
            object-fit: cover;
        }

        .top-bar {
            grid-column: 1 / -1;
            background: rgba(0, 0, 0, 0.85);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            height: 50px;
            z-index: 100;
            /* Ensure on top */
        }

        /* Mobile specific HUD overrides */
        @media (max-width: 1024px) {
            .hud-right .hud-menu-btn {
                display: none;
                /* Hide old menu btn */
            }
        }

        .mobile-hud-btns {
            display: none;
        }

        @media (max-width: 1024px) {
            .mobile-hud-btns {
                display: flex;
                gap: 15px;
            }

            .mobile-icon-btn {
                background: none;
                border: none;
                font-size: 24px;
                cursor: pointer;
                filter: drop-shadow(0 0 2px black);
            }
        }

        /* MOBILE MODAL STYLES */
        .mobile-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2000;
            flex-direction: column;
            padding: 4px;
            /* Tiny padding */
            box-sizing: border-box;
            color: #ccc;
        }

        .mobile-modal.active {
            display: flex;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            /* Compact */
            margin-bottom: 10px;
            flex-shrink: 0;
            /* Keep header visible */
        }

        .modal-body {
            overflow-y: auto;
            /* Enable scrolling */
            flex-grow: 1;
            padding-right: 5px;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--color-gold);
            font-size: 1.2rem;
            /* Smaller font */
        }

        .modal-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.8rem;
            cursor: pointer;
            padding: 0 10px;
        }

        .mobile-stats {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            gap: 2px;
            font-size: 0.85rem;
            /* Small font */
            margin-bottom: 5px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Increased specificity */
        .mobile-modal .mobile-grid {
            display: grid;
            /* SLIGHTLY BIGGER tiles per user request */
            grid-template-columns: repeat(auto-fill, 44px);
            gap: 4px;
            padding-bottom: 10px;
            justify-content: start;
            /* Pack to left */
        }

        .mobile-grid .eq-slot {
            width: 44px;
            /* Bigger tiles */
            height: 44px;
            /* Fixed height */
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mobile-grid .eq-slot img {
            width: 75%;
            /* Visually smaller inside the box */
            height: 75%;
            object-fit: contain;
        }

        .quest-list {
            list-style: none;
            padding: 0;
            font-size: 1.1rem;
            line-height: 1.5;
        }

        /* LANDSCAPE OPTIMIZATION */
        @media (max-width: 1024px) and (orientation: landscape) {
            .mobile-modal {
                flex-direction: row;
                padding: 4px;
                gap: 10px;
                /* More gap between sidebar and grid */
            }

            .modal-header {
                display: none;
                /* Hide standard header in landscape to save space */
            }

            /* Create a sidebar for stats */
            .mobile-modal>.modal-body {
                display: flex;
                flex-direction: row;
                gap: 15px;
                /* Distinct gap */
                width: 100%;
                padding: 0;
            }

            .mobile-stats {
                flex-direction: column;
                width: 150px;
                /* WIDER sidebar to prevent overlap */
                justify-content: flex-start;
                gap: 5px;
                padding-top: 5px;
                border-right: 1px solid #444;
                font-size: 0.85rem;
                margin: 0;
                background: rgba(0, 0, 0, 0.2);
                /* Slight dim to separate */
                flex-shrink: 0;
                /* Prevent shrinking */
                padding-right: 5px;
            }

            /* Increased specificity to override .eq-grid */
            .mobile-modal .mobile-grid {
                flex-grow: 1;
                /* FIXED 44px columns */
                grid-template-columns: repeat(auto-fill, 44px);
                padding-right: 25px;
                gap: 4px;
                justify-content: start;
            }

            /* Absolute Close Button for Landscape */
            .modal-close-landscape {
                position: absolute;
                top: 0;
                right: 0;
                font-size: 1.2rem;
                padding: 5px;
                z-index: 2005;
                background: rgba(0, 0, 0, 0.5);
                border-bottom-left-radius: 5px;
                display: block !important;
            }
        }

        /* Force override for .eq-grid inside mobile modal regardless of order */
        .mobile-modal .eq-grid {
            grid-template-columns: repeat(auto-fill, 44px) !important;
        }

        .modal-close-landscape {
            display: none;
        }

        /* Hidden by default */

        /* Game Map Area */
        .game-map-container {
            grid-column: 2;
            grid-row: 2;
            position: relative;
            background: linear-gradient(to bottom, #050505 0%, #1a1a1a 100%);
            overflow: hidden;
            border: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            /* ENABLES 3D DEPTH */
        }

        /* The actual game world - ISOMETRIC VIEW */
        #worldGrid {
            position: absolute;
            width: 800px;
            height: 800px;
            background-color: #1a1a1a;
            /* Side View Tilted Perspective */
            transform: rotateX(60deg);
            transform-style: preserve-3d;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5) inset;
            border: 10px solid #111;
            left: 0;
            top: 0;

            /* NO CSS TRANSITION - JavaScript lerp handles smooth camera */
            will-change: transform;

            /* Grid floor texture - NOW HANDLED BY TILES */
            background-color: #0b1a0b;
            border: 10px solid #0d1a0d;
            box-shadow: 0 40px 80px rgba(0, 0, 0, 0.9);
            transform-style: preserve-3d;
        }

        .tile {
            position: absolute;
            width: 32px;
            height: 32px;
            background-color: #1a2f1a;
            border: 1px solid rgba(0, 0, 0, 0.3);
            box-sizing: border-box;
            background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, transparent 100%);
        }

        .entity {
            position: absolute;
            width: 32px;
            height: 32px;

            /* NO TRANSITION - instant snap, camera handles all smoothness */
            transition: none;

            transform-style: preserve-3d;
            transform: translate3d(0, 0, 10px) rotateX(-60deg) translate(0, -50%) scale(1.0);
            transform-origin: bottom center;

            /* REMOVED BACKGROUND/PADDING PER USER REQUEST */
            background: none;
            padding: 0;
            border: none;

            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            /* GPU acceleration for smooth movement */
            will-change: left, top, transform;
            filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.5));
        }

        .player-token {
            z-index: 100;
        }

        .player-token img {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            /* Capsule shape */
            /* Removed red shadow/border per request */
            /* border: 2px solid var(--color-gold); */
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
            object-fit: cover;
        }

        .npc {
            /* Removed red bg */
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            font-size: 20px;
        }

        /* Monster Styles */
        .monster {
            width: 24px;
            height: 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        .monster-img {
            width: 24px;
            height: 24px;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .monster-emoji {
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .monster-name {
            font-size: 5px;
            color: #ff6666;
            text-shadow: 0 1px 2px black;
            white-space: nowrap;
        }

        .monster-hp-bar {
            width: 40px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-bottom: 2px;
        }

        .monster-hp-fill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ff0000);
            border-radius: 2px;
            transition: width 0.2s ease;
        }

        /* Floating Damage */
        .floating-damage {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 3px black, 0 0 6px black;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 1000;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            50% {
                opacity: 1;
                transform: translateY(-30px) scale(1.2);
            }

            100% {
                opacity: 0;
                transform: translateY(-60px) scale(0.8);
            }
        }

        /* IRATUS-STYLE COMBAT SCREEN */
        #combatScreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 2000;
            /* iOS safe area */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            box-sizing: border-box;
        }

        #combatScreen.active {
            display: flex;
        }

        .combat-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('img/locations/lodowa.png') center center;
            background-size: cover;
            opacity: 0.6;
            z-index: 0;
        }

        /* In-game message overlay (replaces alert) */
        .game-message-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }

        .game-message {
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.98));
            border: 2px solid var(--color-gold);
            border-radius: 15px;
            padding: 30px 50px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .game-message.success {
            border-color: #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.4);
        }

        .game-message.error {
            border-color: #f44336;
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.4);
        }

        .game-message-text {
            font-size: 1.8rem;
            color: #fff;
            font-family: 'Cinzel', serif;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .game-message-btn {
            background: linear-gradient(135deg, var(--color-gold), #ffd700);
            border: none;
            color: #000;
            padding: 12px 40px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .game-message-btn:hover,
        .game-message-btn:active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Force landscape globally on portrait mobile */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            body {
                transform: rotate(90deg);
                transform-origin: left top;
                width: 100vh;
                height: 100vw;
                position: fixed;
                top: 0;
                left: 100%;
                overflow: hidden;
            }

            #joystickContainer {
                /* Adjust joystick if needed, or it rotates with body */
            }
        }

        .combatant-mana-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .combatant-mana-fill {
            height: 100%;
            background: linear-gradient(90deg, #0055ff, #00ccff);
            width: 100%;
            transition: width 0.3s;
        }

        /* --- COMPACT & MOBILE COMBAT STYLES --- */
        .combat-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
            padding: 10px;
            box-sizing: border-box;
        }

        .combat-main-area {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            padding: 0 5%;
        }

        .combat-side {
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        .combatant {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .combatant-info-row {
            display: flex;
            gap: 8px;
            align-items: baseline;
            text-shadow: 0 0 5px black;
        }

        .combatant-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .combatant-level {
            font-size: 11px;
            color: #ffd700;
        }

        .combatant-sprite {
            font-size: 100px;
            /* Scaling base for emojis */
            transition: transform 0.2s;
            margin: 5px 0;
        }

        .combatant-sprite img {
            width: 160px !important;
            height: 160px !important;
            object-fit: contain;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
        }

        .combatant-sprite.attacking {
            animation: attackAnim 0.3s ease-out;
        }

        .combatant-sprite.hit {
            animation: hitAnim 0.3s ease-out;
        }

        .enemy-combatant .combatant-sprite.attacking {
            animation: attackAnimEnemy 0.3s ease-out;
        }

        @keyframes attackAnim {
            0% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(30px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes attackAnimEnemy {
            0% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(-30px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes hitAnim {
            0% {
                filter: brightness(1) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
            }

            50% {
                filter: brightness(3) hue-rotate(180deg) drop-shadow(0 0 20px red);
            }

            100% {
                filter: brightness(1) drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
            }
        }

        .combatant-bars {
            width: 100px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .combatant-hp-bar {
            width: 100%;
            height: 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .combatant-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4d4d, #ff0000);
            width: 100%;
            transition: width 0.3s;
        }

        .enemy-hp {
            background: linear-gradient(90deg, #ff8800, #ff4400);
        }

        .combatant-stat-text {
            font-size: 9px;
            color: #fff;
            text-align: center;
            margin-top: -1px;
        }

        .mana-text {
            color: #aaf;
        }

        .combat-vs {
            font-size: 24px;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.2);
            font-family: 'Cinzel', serif;
        }

        /* ACTIONS & LOG */
        .combat-ui {
            height: 140px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            justify-content: flex-end;
            padding-bottom: 5px;
        }

        .combat-log {
            height: 40px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            padding: 4px;
            font-size: 11px;
            color: #ddd;
            text-align: center;
            border-radius: 4px;
            max-width: 300px;
            /* Matched to button row */
            margin: 0 auto;
            /* Center it */
            width: 100%;
        }

        .combat-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 100;
            position: relative;
        }

        .combat-btn {
            background: linear-gradient(to bottom, #555, #333);
            border: 2px solid #888;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px #111;
            transition: transform 0.1s, box-shadow 0.1s;
            min-width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.1;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: none;
        }

        .combat-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 #111;
            background: linear-gradient(to bottom, #666, #444);
        }

        .btn-sub {
            font-size: 9px;
            color: #aaa;
            margin-top: 2px;
        }

        .combat-turn-indicator {
            text-align: center;
            font-size: 12px;
            color: #ffd700;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 2px;
        }

        /* --- POPUP MENU (Glassmorphism) --- */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: none;
            /* Hidden by default */
            justify-content: center;
            align-items: center;
        }

        .menu {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #555;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 24px;
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: relative;
        }

        /* Adjusted button styles for clean look */
        .menu-item {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 12px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #444;
            border-color: #777;
        }

        .close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 24px;
            color: #888;
            cursor: pointer;
            background: none;
            border: none;
        }

        .close-btn:hover {
            color: white;
        }

        #joystickBase {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Chat Removed */

        /* Stats */
        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 5px;
            border-bottom: 1px solid #222;
            padding-bottom: 2px;
        }

        .stat-val {
            color: var(--color-gold);
            font-weight: bold;
        }

        .eq-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-top: 10px;
        }

        .eq-slot {
            aspect-ratio: 1;
            background: #222;
            border: 1px solid #444;
        }

        /* --- ARENA SCREEN (HoMM Style) --- */
        #arenaScreen {
            display: none;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            background: #050505;
            z-index: 1000;
        }

        #arenaScreen.active {
            display: flex;
        }

        .arena-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .arena-sidebar {
            width: 250px;
            background: #111;
            border-right: 2px solid var(--color-border);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .arena-main {
            flex: 1;
            position: relative;
            background: #050505;
            /* Removed image, dark bg */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1200px;
        }

        /* Arena Grid - Smaller, focused */

        /* Arena Grid - Larger & More Tiles */
        #arenaGrid {
            position: relative;
            width: 768px;
            /* 12 * 64 */
            height: 640px;
            /* 10 * 64 */
            /* Side View Perspective */
            transform: rotateX(60deg) translateY(50px);
            transform-style: preserve-3d;
            background-color: rgba(0, 0, 0, 0.2);
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 64px 64px;
            /* Bigger tiles for battle */
            border: none;
            box-shadow: none;
        }

        .arena-tile {
            position: absolute;
            width: 64px;
            height: 64px;
            box-sizing: border-box;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: background 0.2s;
        }

        .arena-tile.move-range {
            background: rgba(0, 255, 0, 0.2);
            cursor: pointer;
            border: 1px solid lime;
        }

        .arena-tile.attack-range {
            background: rgba(255, 0, 0, 0.3);
            cursor: pointer;
            border: 1px solid red;
        }

        .arena-tile:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .arena-unit {
            position: absolute;
            width: 64px;
            height: 64px;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-style: preserve-3d;
            /* Billboard logic - counteract grid rotateX(60deg) */
            /* Slimmer: scale(1.4, 1.8) -> narrower width */
            transform: translate3d(0, 0, 0) rotateX(-60deg) translate(0, -90%) scale(1.4, 1.8);
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .arena-unit img {
            width: 80px;
            height: 80px;
            filter: drop-shadow(0 10px 5px black);
        }

        .arena-unit-hp {
            position: absolute;
            top: -20px;
            background: black;
            border: 1px solid #555;
            height: 6px;
            width: 40px;
        }

        .arena-unit-hp-fill {
            height: 100%;
            background: lime;
            width: 100%;
        }

        .enemy .arena-unit-hp-fill {
            background: red;
        }

        .action-btn {
            background: #222;
            color: var(--color-gold);
            border: 1px solid var(--color-border);
            padding: 10px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.2s;
        }

        .action-btn:hover {
            background: #333;
            border-color: var(--color-gold);
        }

        /* VIRTUAL JOYSTICK */
        #joystickContainer {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 200;
            display: none;
            /* Hidden until game starts */
        }

        #joystickBase {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        /* Mobile Responsive Fixes */
        @media (max-width: 600px) {
            .top-bar {
                padding: 10px 5px;
                gap: 5px;
                flex-wrap: wrap;
                height: auto;
                font-size: 11px;
            }

            .player-info {
                width: 100%;
                order: 3;
                /* Move to bottom line if needed */
                margin-top: 5px;
            }

            /* Wizard Styles */
            .wizard-step {
                display: none;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                animation: fadeIn 0.5s ease;
                width: 100%;
            }

            .wizard-step.active {
                display: flex;
            }

            /* PREMIUM CHARACTER CREATION PANEL */
            .step-1-row {
                display: flex;
                flex-direction: row;
                align-items: flex-end;
                justify-content: space-between;
                /* Name left, Gender right */
                gap: 40px;
                margin: 50px auto;
                padding: 40px 60px;
                background: linear-gradient(145deg, rgba(20, 20, 25, 0.85), rgba(10, 10, 15, 0.95));
                border-radius: 4px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                box-shadow:
                    0 20px 50px rgba(0, 0, 0, 0.8),
                    inset 0 0 30px rgba(255, 215, 0, 0.05);
                backdrop-filter: blur(12px);
                position: relative;
                overflow: visible;
                width: 100%;
                max-width: 700px;
            }

            /* Decorative Corners */
            .step-1-row::before,
            .step-1-row::after {
                content: '';
                position: absolute;
                width: 20px;
                height: 20px;
                border: 2px solid var(--color-gold);
                opacity: 0.6;
            }

            .step-1-row::before {
                top: -2px;
                left: -2px;
                border-right: 0;
                border-bottom: 0;
            }

            .step-1-row::after {
                bottom: -2px;
                right: -2px;
                border-left: 0;
                border-top: 0;
            }

            .input-wrapper {
                position: relative;
                width: 300px;
                display: flex;
                flex-direction: column;
            }

            .input-label {
                font-family: 'Outfit', sans-serif;
                font-size: 0.85rem;
                /* Slightly larger */
                font-weight: 600;
                /* Bolder */
                text-transform: uppercase;
                letter-spacing: 2px;
                color: var(--color-gold);
                margin-bottom: 12px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);
                /* Strong shadow to separate from background */
                text-align: left;
                display: block;
            }

            #playerNameInput {
                padding: 12px 10px;
                font-size: 1.8rem;
                font-family: inherit;
                background: rgba(0, 0, 0, 0.2);
                /* Added subtle background for better contrast */
                border: none;
                border-bottom: 2px solid rgba(255, 215, 0, 0.3);
                color: #fff;
                text-align: left;
                width: 100%;
                outline: none;
                transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                letter-spacing: 1px;
                text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            }

            #playerNameInput:focus {
                border-bottom-color: var(--color-gold);
                padding-left: 20px;
                background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent);
                text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            }

            #playerNameInput::placeholder {
                color: rgba(255, 255, 255, 0.4);
                /* Increased placeholder visibility */
                font-size: 1.4rem;
            }

            .gender-selection-side {
                display: flex;
                gap: 15px;
                flex-direction: row;
                align-items: flex-end;
                /* Align with bottom of input */
                padding-bottom: 5px;
                /* Fine-tune alignment with input field */
            }

            .gender-btn {
                width: 50px;
                height: 50px;
                border: 1px solid rgba(255, 215, 0, 0.2);
                background: rgba(0, 0, 0, 0.4);
                border-radius: 50%;
                /* Circle buttons for cleaner look */
                cursor: pointer;
                font-size: 1.4rem;
                transition: 0.3s all cubic-bezier(0.4, 0, 0.2, 1);
                display: flex;
                align-items: center;
                justify-content: center;
                color: #888;
                position: relative;
            }

            /* Tooltip behavior for circles */
            .gender-btn::after {
                content: attr(data-label);
                position: absolute;
                bottom: -25px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 0.65rem;
                text-transform: uppercase;
                letter-spacing: 1px;
                white-space: nowrap;
                opacity: 0;
                transition: 0.3s;
                color: var(--color-gold);
                pointer-events: none;
            }

            .gender-btn:hover {
                border-color: var(--color-gold);
                background: rgba(255, 215, 0, 0.1);
                color: white;
                transform: translateY(-3px);
            }

            .gender-btn:hover::after {
                opacity: 1;
                bottom: -30px;
            }

            .gender-btn.active {
                border-color: var(--color-gold);
                background: rgba(255, 215, 0, 0.25);
                color: var(--color-gold);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
                transform: scale(1.1);
            }

            .gender-btn.active::after {
                opacity: 1;
                font-weight: bold;
                color: var(--color-gold);
            }

            .error-msg {
                color: #ff6b6b;
                margin-top: 15px;
                font-size: 0.85rem;
                text-transform: uppercase;
                letter-spacing: 1px;
                text-align: center;
                min-height: 20px;
            }

            .wizard-btn {
                padding: 15px 50px;
                font-size: 1rem;
                text-transform: uppercase;
                letter-spacing: 4px;
                border: 1px solid var(--color-gold);
                background: transparent;
                color: var(--color-gold);
                cursor: pointer;
                transition: 0.4s;
                margin-top: 30px;
                position: relative;
                overflow: hidden;
            }

            .wizard-btn:hover {
                background: var(--color-gold);
                color: black;
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
            }

            .back-btn {
                margin-top: 20px;
                background: none;
                border: none;
                color: #888;
                cursor: pointer;
                font-size: 1rem;
                transition: 0.3s;
            }

            .back-btn:hover {
                color: white;
            }

            .orb.disabled {
                opacity: 0.5;
                pointer-events: none;
                filter: grayscale(1);
            }

            .char-attribute {
                font-size: 0.8rem;
                color: #aaa;
                margin-top: 5px;
                font-style: italic;
            }
        }

        /* WIZARD STYLES - GLOBAL (outside media query) */
        .wizard-step {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            animation: fadeIn 0.5s ease;
            width: 100%;
        }

        .wizard-step.active {
            display: flex;
        }

        /* Step 2 needs scrolling for cards */
        #step-class {
            justify-content: flex-start;
            padding: 30px 20px;
            overflow-y: auto;
            height: auto;
            min-height: 100vh;
        }

        .step-1-row {
            display: flex !important;
            flex-direction: row !important;
            align-items: flex-end;
            justify-content: space-between;
            gap: 40px;
            margin: 50px auto;
            padding: 40px 60px;
            background: linear-gradient(145deg, rgba(20, 20, 25, 0.85), rgba(10, 10, 15, 0.95));
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.15);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(255, 215, 0, 0.05);
            backdrop-filter: blur(12px);
            position: relative;
            overflow: visible;
            width: 100%;
            max-width: 700px;
        }

        .step-1-row::before,
        .step-1-row::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--color-gold);
            opacity: 0.6;
        }

        .step-1-row::before {
            top: -2px;
            left: -2px;
            border-right: 0;
            border-bottom: 0;
        }

        .step-1-row::after {
            bottom: -2px;
            right: -2px;
            border-left: 0;
            border-top: 0;
        }

        .input-wrapper {
            position: relative;
            width: 300px;
            display: flex;
            flex-direction: column;
        }

        .input-label {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--color-gold);
            margin-bottom: 12px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);
            text-align: left;
            display: block;
        }

        #playerNameInput {
            padding: 12px 10px;
            font-size: 1.8rem;
            font-family: inherit;
            background: rgba(0, 0, 0, 0.2);
            border: none;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
            color: #fff;
            text-align: left;
            width: 100%;
            outline: none;
            transition: all 0.4s;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #playerNameInput:focus {
            border-bottom-color: var(--color-gold);
            padding-left: 20px;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent);
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        #playerNameInput::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-size: 1.4rem;
        }

        .gender-selection-side {
            display: flex !important;
            flex-direction: row !important;
            gap: 15px;
            align-items: center;
        }

        .gender-btn {
            width: 50px;
            height: 50px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.4rem;
            transition: 0.3s all;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
        }

        .gender-btn:hover {
            border-color: var(--color-gold);
            background: rgba(255, 215, 0, 0.1);
            color: white;
            transform: translateY(-3px);
        }

        .gender-btn.active {
            border-color: var(--color-gold);
            background: rgba(255, 215, 0, 0.25);
            color: var(--color-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
            transform: scale(1.1);
        }

        .error-msg {
            color: #ff6b6b;
            margin-top: 15px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            min-height: 20px;
        }

        .orb.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(1);
        }

        .back-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
            cursor: pointer;
            font-size: 1rem;
            padding: 10px 25px;
            border-radius: 4px;
            transition: 0.3s;
            letter-spacing: 1px;
        }

        .back-btn:hover {
            color: white;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }

        .step2-buttons {
            display: flex;
            align-items: center;
            gap: 30px;
            margin-top: 30px;
            padding-bottom: 50px;
        }

        .step2-buttons .orb-right {
            position: relative;
            bottom: auto;
            right: auto;
        }

        /* Back button at top left */
        .back-btn-top {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: var(--color-gold);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 10px 20px;
            border-radius: 4px;
            transition: 0.3s;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
        }

        .back-btn-top:hover {
            border-color: var(--color-gold);
            background: rgba(255, 215, 0, 0.15);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }

        /* GRAJ button fixed at bottom right */
        #step-class .orb-right {
            position: fixed;
            bottom: 30px;
            right: 30px;
        }

        /* Fullscreen hint button */
        .fullscreen-hint {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--color-gold);
            color: var(--color-gold);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            animation: pulseGlow 2s ease-in-out infinite;
        }

        .fullscreen-hint:hover {
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            transform: scale(1.05);
        }

        #step-name {
            overflow: hidden;
            padding-top: 50px;
        }

        .wizard-btn-panel {
            padding: 12px 35px !important;
            font-size: 0.9rem !important;
            margin-top: 0 !important;
            letter-spacing: 3px !important;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 180, 0, 0.05)) !important;
            border: 1px solid var(--color-gold) !important;
            color: var(--color-gold) !important;
            border-radius: 4px !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2), inset 0 0 10px rgba(255, 215, 0, 0.05) !important;
            transition: all 0.3s ease !important;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: pulseGlow 2s ease-in-out infinite;
        }

        .wizard-btn-panel:hover {
            background: linear-gradient(135deg, var(--color-gold), #ffcc00) !important;
            color: #1a1a1a !important;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6), 0 5px 20px rgba(0, 0, 0, 0.4) !important;
            transform: translateY(-2px);
            text-shadow: none;
        }

        @keyframes pulseGlow {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.2), inset 0 0 10px rgba(255, 215, 0, 0.05);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.4), inset 0 0 15px rgba(255, 215, 0, 0.1);
            }
        }

        .char-attribute {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 5px;
            font-style: italic;
        }

        /* Wizard Title Styling */
        #selectScreen h1 {
            font-size: 2.5rem;
            color: var(--color-gold);
            text-shadow:
                0 0 20px rgba(255, 215, 0, 0.5),
                0 4px 10px rgba(0, 0, 0, 0.9),
                0 0 40px rgba(255, 215, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 30px;
            font-weight: 700;
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.7);
            paint-order: stroke fill;
        }

        @media (max-width: 768px) {

            /* Hide desktop panels on mobile */
            .panel {
                display: none !important;
            }

            /* Make map take full screen */
            .game-map-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100% !important;
                height: 100% !important;
                z-index: 1;
            }

            /* Adjust HUD for mobile */
            .top-bar {
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(2px);
                padding: 5px 10px;
                height: 50px;
                z-index: 10;
                justify-content: space-between;
                width: 100%;
                position: fixed;
                top: 0;
                left: 0;
            }

            #mobileHud {
                display: flex !important;
            }

            /* Show mobile buttons, hide desktop specific ones */
            .mobile-hud-btns {
                display: flex !important;
            }

            .hud-menu-btn {
                display: none !important;
            }

            /* Joystick visible */
            #joystickContainer {
                display: block !important;
            }

            /* Adjust Chat/Logs position if needed */
            #chatContainer {
                bottom: 15px;
                left: 15px;
                width: 250px;
                font-size: 10px;
                opacity: 0.8;
                pointer-events: none;
                /* Let clicks pass through */
            }

            /* Ensure modals are full screen or well centered */
            .modal-content {
                width: 95%;
                height: 90%;
            }

            /* -- FIX iOS COMBAT SCREEN -- */
            #combatScreen {
                height: 100dvh !important;
                /* Force dynamic viewport height */
                padding-bottom: env(safe-area-inset-bottom) !important;
            }

            .combat-container {
                height: 100% !important;
                display: flex;
                flex-direction: column;
                justify-content: flex-end;
                /* Align content to bottom */
            }

            .combat-ui {
                height: auto !important;
                padding-bottom: 20px !important;
                /* Extra bottom padding */
                margin-bottom: env(safe-area-inset-bottom);
                flex-shrink: 0;
            }

            /* Make combatants visible above UI */
            .combat-main {
                flex-grow: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                padding-bottom: 20px;
            }

        }

        /* -- FIX iOS COMBAT SCREEN (LANDSCAPE SPECIFIC) -- */
        /* Increased to 1000px width to cover ALL mobile phones in landscape */
        @media (orientation: landscape) and (max-width: 1000px) {
            body {
                position: fixed;
                width: 100%;
                height: 100%;
                overflow: hidden;
            }

            #combatScreen {
                height: 100% !important;
                position: fixed;
                top: 0;
                left: 0;
                overflow: hidden;
                zoom: 0.9;
            }

            .combat-container {
                padding-bottom: 60px !important;
                justify-content: center;
            }

            /* Scale combat visuals */
            .combat-main-area {
                transform: scale(0.85);
                /* Even bigger (was 0.75) */
                transform-origin: center bottom;
                margin-bottom: 0;
                flex-grow: 1;
                display: flex;
                align-items: flex-end;
                justify-content: space-around;
                /* SPREAD THEM OUT */
                width: 80%;
                /* Don't use full width */
                margin-left: auto;
                margin-right: auto;
                padding-bottom: 50px !important;
            }

            /* Enhanced visuals for bars */
            .combatant-bars {
                margin-top: -10px !important;
                position: relative;
                z-index: 5;
                transform: scale(1.0);
                background: rgba(0, 0, 0, 0.5);
                padding: 4px;
                border-radius: 6px;
                backdrop-filter: blur(2px);
            }

            .combatant-sprite {
                margin-bottom: 5px !important;
                filter: drop-shadow(0 10px 10px rgba(0, 0, 0, 0.5));
                /* Better shadow */
            }

            /* MODERN GLASS UI */
            .combat-ui {
                position: fixed !important;
                bottom: 20px !important;
                left: 10%;
                /* Center cleaner */
                width: 80%;
                padding-bottom: 10px !important;
                padding-top: 35px !important;

                /* Glassmorphism */
                background: rgba(16, 16, 20, 0.65);
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);

                border-radius: 20px;
                z-index: 9999;
                height: auto !important;
                margin-bottom: env(safe-area-inset-bottom);
                display: flex;
                flex-direction: column;
                justify-content: flex-end;
            }

            /* Log Integrated into Glass UI */
            .combat-log {
                display: block !important;
                position: absolute;
                top: 8px;
                left: 0;
                width: 100%;
                height: 20px;
                line-height: 20px;
                font-size: 12px !important;
                font-weight: 600;
                letter-spacing: 0.5px;
                color: rgba(255, 255, 255, 0.9);
                background: transparent;
                border-bottom: none;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                text-align: center;
                margin: 0 !important;
                padding: 0 10px;
                pointer-events: none;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            }

            .combat-actions {
                display: flex;
                justify-content: center;
                gap: 15px;
                /* More spacing between buttons */
            }

            .combat-btn {
                padding: 5px 15px !important;
                font-size: 14px !important;
                min-width: 60px !important;
                height: 44px !important;
                background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
                border: 1px solid rgba(255, 255, 255, 0.15);
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
                border-radius: 12px;
            }

            .combat-btn:active {
                transform: scale(0.95);
            }

            .combat-turn-indicator {
                display: none;
            }

            .combat-vs {
                display: none !important;
            }
        }
    </style>
</head>

<body>

    <!-- Rotate Phone Overlay -->
    <div class="rotate-overlay">
        <div class="rotate-icon">📱</div>
        <h2>Obróć telefon</h2>
        <p>Gra działa tylko w trybie poziomym</p>
        <div class="rotate-buttons">
            <button class="rotate-fullscreen-btn" onclick="toggleFullscreen()">📺 Pełny Ekran</button>
            <button class="rotate-fullscreen-btn" onclick="tryLockLandscape()">🔄 Zablokuj Poziomo</button>
            <button class="rotate-fullscreen-btn" id="installBtn" onclick="installPWA()" style="display:none;">📲
                Zainstaluj Grę</button>
        </div>
        <p style="font-size: 0.8rem; margin-top: 20px; opacity: 0.6;">iOS: Dodaj do ekranu głównego przez Share → "Dodaj
            do ekranu początkowego"</p>
    </div>

    <!-- SELECT SCREEN -->
    <!-- SELECT SCREEN (WIZARD) -->
    <div id="selectScreen">
        <!-- Fullscreen button -->
        <button class="fullscreen-hint" onclick="toggleFullscreen()">📺 Pełny Ekran</button>

        <!-- STEP 1: NAME & GENDER (Side-by-Side) -->
        <div id="step-name" class="wizard-step active">
            <h1>Stwórz Bohatera <span style="font-size: 0.8rem; color: #555; vertical-align: middle;">v1.6</span></h1>

            <div class="step-1-row">
                <!-- Left: Name -->
                <div class="input-wrapper">
                    <label class="input-label">Imię Twojej Postaci</label>
                    <input type="text" id="playerNameInput" placeholder="Np. Arthas..." maxlength="15"
                        onkeyup="if(event.key === 'Enter') nextStep(1)">
                </div>

                <!-- Right: Gender -->
                <div class="gender-selection-side">
                    <div class="gender-btn" id="btn-male" data-label="Mężczyzna" onclick="selectGender('male')">♂️</div>
                    <div class="gender-btn" id="btn-female" data-label="Kobieta" onclick="selectGender('female')">♀️
                    </div>
                </div>

                <!-- Button inside panel -->
                <button class="wizard-btn wizard-btn-panel" id="nextStepBtn" onclick="nextStep(1)"
                    style="display: none;">Dalej ➜</button>
            </div>
            <div class="error-msg" id="nameError"></div>
        </div>

        <!-- STEP 2: CLASS/AVATAR ONLY -->
        <div id="step-class" class="wizard-step">
            <button class="back-btn-top" onclick="prevStep(2)">⬅ Cofnij</button>
            <h1>Wybierz Postać</h1>

            <div class="grid" id="charGrid"></div>

            <div class="orb orb-right disabled" id="playBtn" onclick="startGame()">GRAJ</div>
        </div>
    </div>
    <!-- GAME SCREEN -->
    <div id="gameScreen">
        <!-- Default: Menu hidden -->
        <div class="game-layout menu-hidden" id="gameLayout">
            <!-- MOBILE HUD -->
            <div class="top-bar" id="mobileHud">
                <div class="hud-left">
                    <img id="hudAvatar" class="player-avatar-mini" src="" alt="">
                    <div class="hud-bars">
                        <div class="hud-bar hp">
                            <div class="hud-bar-fill hp-fill" style="width: 100%"></div>
                            <span class="hud-bar-text" id="hpText">100/100</span>
                        </div>
                        <div class="hud-bar mana">
                            <div class="hud-bar-fill mana-fill" style="width: 80%"></div>
                            <span class="hud-bar-text">50/50</span>
                        </div>
                    </div>
                </div>
                <div class="hud-center">
                    <span id="hudName">GRACZ</span>
                    <span class="hud-level" id="hudLevel">Lv.1</span>
                    <span style="font-size:0.7rem; color:#aaa;" id="hudXP">0/0 XP</span>
                </div>
                <div class="hud-right">
                    <span class="hud-gold">💰 <span id="goldText">0</span></span>
                    <!-- Mobile Buttons -->
                    <div class="mobile-hud-btns">
                        <button class="mobile-icon-btn" onclick="showSettingsMenu()">⚙️</button>
                        <button class="mobile-icon-btn" onclick="toggleFullscreen()">📺</button>
                        <button class="mobile-icon-btn" onclick="toggleModal('modalInventory')">🎒</button>
                        <button class="mobile-icon-btn" onclick="toggleModal('modalQuests')">📜</button>
                    </div>
                    <!-- Desktop Menu -->
                    <button class="hud-menu-btn" onclick="toggleFullscreen()" title="Pełny ekran">📺</button>
                    <button class="hud-menu-btn" onclick="toggleMenu()">☰</button>
                </div>
            </div>

            <!-- LEFT PANEL (Menu/Quests) -->
            <div class="panel left-panel">
                <h3 style="margin: 0 0 10px 0; color:var(--color-accent); font-size:14px; text-transform:uppercase;">
                    Zadania</h3>
                <ul style="list-style:none; padding:0; font-size:11px; color:#888;">
                    <li>▹ Zabij Szczury (0/5)</li>
                    <li>▹ Znajdź Stary Miecz</li>
                </ul>
            </div>

            <!-- GAME MAP -->
            <div class="game-map-container">
                <div id="worldGrid">
                    <!-- Player inserted by JS -->
                </div>
            </div>

            <!-- RIGHT PANEL (Stats/Eq) -->
            <div class="panel right-panel">
                <h3 style="margin: 0 0 10px 0; color:var(--color-gold); font-size:14px; text-transform:uppercase;">
                    Statystyki</h3>
                <div class="stat-row"><span>Siła</span><span class="stat-val">10</span></div>
                <div class="stat-row"><span>Zręczność</span><span class="stat-val">5</span></div>
                <div class="stat-row"><span>Inteligencja</span><span class="stat-val">2</span></div>
                <div class="stat-row"><span>Pancerz</span><span class="stat-val">15</span></div>

                <div style="display:flex; justify-content:space-between; align-items:center; margin: 20px 0 5px 0;">
                    <h3 style="margin: 0; color:#888; font-size:12px;">EKWIPUNEK</h3>
                    <button onclick="showSettingsMenu()"
                        style="background:none; border:none; font-size:16px; cursor:pointer; color:#888;"
                        title="Ustawienia">⚙️</button>
                </div>
                <div class="eq-grid">
                    <div class="eq-slot"><img src="img/potions/miksturaleczenia.png" title="Mikstura Leczenia"
                            style="width:100%; height:100%;"></div>
                    <div class="eq-slot"><img src="img/potions/manamikstura.png" title="Mikstura Many"
                            style="width:100%; height:100%;"></div>
                    <div class="eq-slot"><img src="img/mounts/kon1.png" title="Wierzchowiec: Koń"
                            style="width:100%; height:100%;"></div>
                    <div class="eq-slot"><img src="img/mounts/wilk.png" title="Wierzchowiec: Wilk"
                            style="width:100%; height:100%;"></div>
                    <div class="eq-slot"></div>
                    <div class="eq-slot"></div>
                    <div class="eq-slot"></div>
                </div>
            </div>

        </div>

        <!-- Virtual Joystick -->
        <div id="joystickContainer">
            <div id="joystickBase">
                <div id="joystickKnob"></div>
            </div>
        </div>
    </div>

    <!-- Combat Screen (Iratus Style - Compact) -->
    <div id="combatScreen">
        <div class="combat-bg"></div>

        <div class="combat-container">
            <div class="combat-main-area">
                <!-- Player Side (Left) -->
                <div class="combat-side player-side">
                    <div class="combatant player-combatant" id="playerCombatant">
                        <div class="combatant-info-row">
                            <div class="combatant-name" id="playerCombatName">GRACZ</div>
                            <div class="combatant-level" id="playerCombatLevel">Lvl 1</div>
                        </div>
                        <div class="combatant-sprite" id="playerCombatSprite">🧙</div>
                        <div class="combatant-bars">
                            <div class="combatant-hp-bar">
                                <div class="combatant-hp-fill" id="playerCombatHP" style="width: 100%"></div>
                            </div>
                            <div class="combatant-stat-text" id="playerHPText">100/100</div>

                            <div class="combatant-mana-bar">
                                <div class="combatant-mana-fill" id="playerCombatMana" style="width: 100%"></div>
                            </div>
                            <div class="combatant-stat-text mana-text" id="playerManaText">50/50</div>
                        </div>
                    </div>
                </div>

                <!-- VS visual -->
                <div class="combat-vs">VS</div>

                <!-- Enemy Side (Right) -->
                <div class="combat-side enemy-side">
                    <div class="combatant enemy-combatant" id="enemyCombatant">
                        <div class="combatant-info-row">
                            <div class="combatant-name" id="enemyCombatName">BESTIA</div>
                            <div class="combatant-level" id="enemyCombatLevel">Lvl 1</div>
                        </div>
                        <div class="combatant-sprite" id="enemyCombatSprite">👹</div>
                        <div class="combatant-bars">
                            <div class="combatant-hp-bar">
                                <div class="combatant-hp-fill enemy-hp" id="enemyCombatHP" style="width: 100%"></div>
                            </div>
                            <div class="combatant-stat-text" id="enemyHPText">50/50</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Combat UI Bottom -->
            <div class="combat-ui">
                <div class="combat-log" id="combatLog">
                    > Walka rozpoczęta!
                </div>
                <!-- New Skills Layout -->
                <div class="combat-actions" id="combatActions">
                    <button class="combat-btn attack-btn" onclick="combatSkill('attack')">
                        ⚔️ <br><span class="btn-sub">0 MP</span>
                    </button>
                    <button class="combat-btn skill-btn" onclick="combatSkill('fireball')">
                        🔥 <br><span class="btn-sub">20 MP</span>
                    </button>
                    <button class="combat-btn heal-btn" onclick="combatSkill('heal')">
                        ❤️ <br><span class="btn-sub">15 MP</span>
                    </button>
                    <button class="combat-btn flee-btn" onclick="combatFlee()">
                        🏃
                    </button>
                </div>
                <div class="combat-turn-indicator" id="turnIndicator">TWOJA TURA</div>
            </div>
        </div>
    </div>

    <!-- POPUP MENU OVERLAY -->
    <div id="overlay">
        <div class="menu">
            <button class="close-btn" onclick="toggleMenu()">×</button>
            <div class="menu-item" onclick="alert('Zapisano!')">💾 Zapisz Grę</div>
            <div class="menu-item" onclick="location.reload()">🔄 Wczytaj Grę</div>
            <div class="menu-item" onclick="toggleFullScreen()">📺 Pełny Ekran</div>
            <div class="menu-item" onclick="toggleMenu()">❌ Zamknij</div>
        </div>
    </div>

    <!-- MOBILE MODALS (Hidden by default) -->
    <div id="modalInventory" class="mobile-modal">
        <button class="modal-close-landscape" onclick="toggleModal('modalInventory')">✕</button>
        <div class="modal-header">
            <h2>🎒 Ekwipunek</h2>
            <button class="modal-close" onclick="toggleModal('modalInventory')">✕</button>
        </div>
        <div class="modal-body">
            <!-- Reuse existing content structure but styled for grid -->
            <div class="mobile-stats">
                <div class="stat-row"><span>❤️ HP:</span> <span id="mobHp">100/100</span></div>
                <div class="stat-row"><span>💙 MP:</span> <span id="mobMana">50/50</span></div>
                <div class="stat-row"><span>💰:</span> <span id="mobGold" style="color:gold">0</span></div>
            </div>
            <hr style="border-color:#333; margin:10px 0;">
            <div class="eq-grid mobile-grid">
                <!-- Hardcoded for now, will dynamic later -->
                <div class="eq-slot"><img src="img/potions/miksturaleczenia.png" onclick="alert('Użyto Mikstury!')">
                </div>
                <div class="eq-slot"><img src="img/potions/manamikstura.png" onclick="alert('Użyto Many!')"></div>
                <div class="eq-slot"></div>
                <div class="eq-slot"></div>
                <div class="eq-slot"></div>
                <div class="eq-slot"></div>
            </div>
        </div>
    </div>

    <div id="modalQuests" class="mobile-modal">
        <button class="modal-close-landscape" onclick="toggleModal('modalQuests')">✕</button>
        <div class="modal-header">
            <h2>📜 Zadania</h2>
            <button class="modal-close" onclick="toggleModal('modalQuests')">✕</button>
        </div>
        <div class="modal-body">
            <ul class="quest-list">
                <li>✅ Zabij Szczury (0/5)</li>
                <li>⬜ Znajdź Stary Miecz</li>
                <li>⬜ Porozmawiaj z Karczmarzem</li>
            </ul>
        </div>
    </div>

    <script>
        // --- PROCEDURAL PLAYER CLASS (Global Scope) ---
        class ProceduralPlayer {
            constructor(container) {
                this.canvas = document.createElement('canvas');
                this.canvas.width = 120;
                this.canvas.height = 120;
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                this.animTime = 0;
                this.idleTime = 0;
                this.facing = 0; // 0:Front, 1:Back, 2:Right, 3:Left
                this.isMoving = false;
                this.bodyRotation = 0;
                this.turnFactor = 1;
                // Attack state
                this.isAttacking = false;
                this.attackTimer = 0;
                this.comboHand = 0;
            }

            triggerAttack() {
                if (!this.isAttacking) {
                    this.isAttacking = true;
                    this.attackTimer = 0;
                    this.comboHand = (this.comboHand + 1) % 2;
                    return true; // Attack started
                }
                return false;
            }

            update(dt, inputDx, inputDy) {
                // Attack timer
                if (this.isAttacking) {
                    this.attackTimer += dt * 4;
                    if (this.attackTimer >= 1) {
                        this.isAttacking = false;
                        this.attackTimer = 0;
                    }
                }

                let targetRot = 0, targetTurn = 1;
                if (inputDx !== 0 || inputDy !== 0) {
                    this.isMoving = true;

                    // 8-way facing: 0=S, 1=N, 2=E, 3=W, 4=SE, 5=SW, 6=NE, 7=NW
                    const absX = Math.abs(inputDx);
                    const absY = Math.abs(inputDy);

                    if (absX < 0.1 && inputDy > 0) this.facing = 0;       // S
                    else if (absX < 0.1 && inputDy < 0) this.facing = 1;  // N
                    else if (inputDx > 0 && absY < 0.1) this.facing = 2;  // E
                    else if (inputDx < 0 && absY < 0.1) this.facing = 3;  // W
                    else if (inputDx > 0 && inputDy > 0) this.facing = 4; // SE
                    else if (inputDx < 0 && inputDy > 0) this.facing = 5; // SW
                    else if (inputDx > 0 && inputDy < 0) this.facing = 6; // NE
                    else if (inputDx < 0 && inputDy < 0) this.facing = 7; // NW
                } else {
                    this.isMoving = false;
                }

                // Set target rotation and turn factor based on facing
                // Facing: 0=S, 1=N, 2=E, 3=W, 4=SE, 5=SW, 6=NE, 7=NW
                switch (this.facing) {
                    case 0: targetRot = 0; targetTurn = 1; break;     // S - front
                    case 1: targetRot = 0; targetTurn = -1; break;    // N - back
                    case 2: targetRot = 1; targetTurn = 0; break;     // E - right side
                    case 3: targetRot = -1; targetTurn = 0; break;    // W - left side
                    case 4: targetRot = 0.5; targetTurn = 0.5; break; // SE - front-right
                    case 5: targetRot = -0.5; targetTurn = 0.5; break;// SW - front-left
                    case 6: targetRot = 0.5; targetTurn = -0.5; break;// NE - back-right
                    case 7: targetRot = -0.5; targetTurn = -0.5; break;// NW - back-left
                }

                this.bodyRotation += (targetRot - this.bodyRotation) * 10 * dt;
                this.turnFactor += (targetTurn - this.turnFactor) * 8 * dt;
                if (this.isMoving) { this.animTime += dt * 5; this.idleTime = 0; }
                else { this.animTime = 0; this.idleTime += dt * 2; }
                this.draw();
            }

            draw() {
                const ctx = this.ctx, W = this.canvas.width, H = this.canvas.height, CX = W / 2, GY = H - 20;
                ctx.clearRect(0, 0, W, H);
                const C = { SKIN: '#ffdbac', SKIN_S: '#e0b080', SHIRT: '#8b0000', PANTS: '#263238', SHOES: '#212121', HAIR: '#3e2723' };
                let bob = this.isMoving ? Math.abs(Math.sin(this.animTime)) * 3 : Math.sin(this.idleTime) * 1.5;
                let hipY = GY - 35 - bob, legY = hipY + 12, rot = this.bodyRotation;

                // Direction flags for 8-way facing
                // Cardinal: 0=S, 1=N, 2=E, 3=W; Diagonal: 4=SE, 5=SW, 6=NE, 7=NW
                let isRight = this.facing === 2 || this.facing === 4 || this.facing === 6;
                let isLeft = this.facing === 3 || this.facing === 5 || this.facing === 7;
                let isSide = isRight || isLeft;
                let isBack = this.facing === 1 || this.facing === 6 || this.facing === 7;
                let isFront = this.facing === 0 || this.facing === 4 || this.facing === 5;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(CX, GY, 14, 5, 0, 0, Math.PI * 2); ctx.fill();

                const drawLeg = (left) => {
                    let ph = left ? 0 : Math.PI, ho = (left ? -7 : 7) * (1 - Math.abs(rot) * 0.8);
                    let sw = Math.cos(this.animTime + ph) * (isSide ? -1 : 1), lf = Math.max(0, Math.sin(this.animTime + ph)) * 10;
                    if (!this.isMoving) { sw = 0; lf = 0; } let hx = CX + ho, st = 14, sx = 0;
                    if (isRight) sx = sw * st; else if (isLeft) sx = sw * -st;
                    let fx = hx + sx, fy = GY - lf, kx = (hx + fx) / 2 + sx * 0.2, ky = (legY + fy) / 2;
                    ctx.lineWidth = 8; ctx.strokeStyle = C.PANTS; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(hx, legY); ctx.quadraticCurveTo(kx, ky, fx, fy); ctx.stroke();
                    ctx.fillStyle = C.SHOES; ctx.beginPath(); ctx.ellipse(fx, fy, 6, 3, 0, 0, Math.PI * 2); ctx.fill();
                };

                const drawArm = (left) => {
                    let sx = CX + (left ? -13 : 13) * (1 - Math.abs(rot) * 0.6);
                    let sy = hipY - 24;
                    let ph = left ? Math.PI : 0;
                    let hx = sx, hy = sy + 25;
                    let activeArm = (this.comboHand === 0) ? !left : left;

                    // ATTACK ANIMATION
                    if (this.isAttacking && activeArm) {
                        let progress = this.attackTimer;
                        let extension = progress < 0.3 ? progress / 0.3 : 1 - ((progress - 0.3) / 0.7);

                        let attackDirX = 0, attackDirY = 1;
                        if (isRight) { attackDirX = 1; attackDirY = 0; }
                        else if (isLeft) { attackDirX = -1; attackDirY = 0; }
                        else if (isBack) { attackDirX = 0; attackDirY = -1; }

                        let reach = 20;
                        hx = sx + (attackDirX * reach * extension) + (attackDirX * 5);
                        hy = sy + 5 + (attackDirY * reach * extension * 0.5) - (extension * 8);

                        // Swing trail
                        if (progress > 0.1 && progress < 0.4) {
                            ctx.save();
                            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(hx - attackDirX * 10, hy - attackDirY * 5);
                            ctx.lineTo(hx, hy);
                            ctx.stroke();
                            ctx.restore();
                        }
                    } else {
                        // Normal movement
                        if (this.isMoving) {
                            let sw = Math.cos(this.animTime + ph) * 15;
                            if (isSide) hx += sw; else hy -= Math.abs(sw) * 0.5;
                        } else {
                            hx += Math.sin(this.idleTime) * 2;
                        }
                    }

                    ctx.strokeStyle = C.SHIRT; ctx.lineWidth = 7; ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(hx, hy); ctx.stroke();
                    let handRadius = (this.isAttacking && activeArm) ? 6 : 4;
                    ctx.fillStyle = C.SKIN; ctx.beginPath(); ctx.arc(hx, hy, handRadius, 0, Math.PI * 2); ctx.fill();
                };

                if (isBack) { drawLeg(true); drawLeg(false); drawArm(true); drawArm(false); } else { drawLeg(true); drawLeg(false); }
                ctx.fillStyle = C.SHIRT; ctx.beginPath(); let w = 14 - Math.abs(rot) * 5;
                ctx.moveTo(CX - w, hipY - 28); ctx.lineTo(CX + w, hipY - 28); ctx.lineTo(CX + w - 2, hipY + 10); ctx.lineTo(CX - w + 2, hipY + 10); ctx.fill();
                if (!isBack) { drawArm(true); drawArm(false); }
                let headY = hipY - 42, headX = CX + rot * 4;
                ctx.fillStyle = C.SKIN_S; ctx.fillRect(headX - 4, headY + 12, 8, 8);
                ctx.fillStyle = C.SKIN; ctx.beginPath(); ctx.arc(headX, headY, 13, 0, Math.PI * 2); ctx.fill();
                if (!isBack) {
                    ctx.fillStyle = '#111'; if (isSide) { ctx.beginPath(); ctx.arc(headX + (isRight ? 5 : -5), headY, 2, 0, Math.PI * 2); ctx.fill(); }
                    else { ctx.beginPath(); ctx.arc(headX - 4, headY, 2, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(headX + 4, headY, 2, 0, Math.PI * 2); ctx.fill(); }
                }
                ctx.fillStyle = C.HAIR; ctx.beginPath(); ctx.arc(headX, headY - 2, 14, 0, Math.PI * 2);
                ctx.moveTo(headX - 14, headY - 5); ctx.quadraticCurveTo(headX, headY - 20, headX + 14, headY - 5);
                if (isBack) { ctx.lineTo(headX + 14, headY + 8); ctx.quadraticCurveTo(headX, headY + 15, headX - 14, headY + 8); }
                else { ctx.lineTo(headX + 14, headY + 2); ctx.quadraticCurveTo(headX, headY - 5, headX - 14, headY + 2); }
                ctx.fill();
            }
        }

        // --- MONSTERS ---
        const monsters = [];

        function createMonster(x, y, name, hp, visual) {
            return {
                x: x * TILE_SIZE,
                y: y * TILE_SIZE,
                hp: hp,
                maxHp: hp,
                name: name,
                visual: visual, // Can be emoji or image path
                element: null
            };
        }

        function spawnMonster(world, monster) {
            const el = document.createElement('div');
            el.className = 'entity monster';

            // Check if visual is image path or emoji
            let visualHtml;
            if (monster.visual.includes('.png') || monster.visual.includes('.jpg')) {
                visualHtml = `<img class="monster-img" src="img/${monster.visual}" alt="${monster.name}">`;
            } else {
                visualHtml = `<div class="monster-emoji">${monster.visual}</div>`;
            }

            el.innerHTML = `
                <div class="monster-name">${monster.name} Lv.1</div>
                <div class="monster-hp-bar"><div class="monster-hp-fill" style="width:100%"></div></div>
                ${visualHtml}
            `;
            el.style.left = monster.x + 'px';
            el.style.top = monster.y + 'px';
            el.style.zIndex = Math.floor(monster.x / TILE_SIZE + monster.y / TILE_SIZE);
            world.appendChild(el);
            monster.element = el;
        }

        function updateMonsterHP(monster) {
            if (!monster.element) return;
            const fill = monster.element.querySelector('.monster-hp-fill');
            if (fill) {
                const pct = Math.max(0, monster.hp / monster.maxHp * 100);
                fill.style.width = pct + '%';
            }
        }

        function checkAttackHit() {
            if (!window.proceduralPlayer || !window.proceduralPlayer.isAttacking) return;

            const attackRange = TILE_SIZE * 2; // Balanced range (2 tiles)

            for (let i = monsters.length - 1; i >= 0; i--) {
                const m = monsters[i];
                // Center of monster
                const mx = m.x + 12;
                const my = m.y + 12;
                const dist = Math.sqrt((playerPixelX - mx) ** 2 + (playerPixelY - my) ** 2);

                if (dist < attackRange) {
                    // Hit!
                    const damage = 10 + Math.floor(Math.random() * 10);
                    m.hp -= damage;
                    updateMonsterHP(m);

                    // Floating damage
                    showFloatingDamage(m.x, m.y, damage);

                    if (m.hp <= 0) {
                        // Monster died
                        if (m.element) m.element.remove();
                        monsters.splice(i, 1);
                        showFloatingDamage(m.x, m.y - 20, '💀 DEAD!', 'gold');
                    }
                    break; // Hit one monster per attack
                }
            }
        }

        function showFloatingDamage(x, y, text, color = 'red') {
            const el = document.createElement('div');
            el.className = 'floating-damage';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.color = color;
            el.textContent = typeof text === 'number' ? '-' + text : text;
            document.getElementById('worldGrid').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        let lastHitTime = 0;
        function triggerPlayerAttack() {
            if (window.proceduralPlayer && window.proceduralPlayer.triggerAttack()) {
                // Check for hits multiple times during attack animation
                const now = Date.now();
                if (now - lastHitTime > 200) { // Prevent spam
                    lastHitTime = now;
                    checkAttackHit();
                    setTimeout(checkAttackHit, 80);
                    setTimeout(checkAttackHit, 160);
                }
            }
        }
        // --- DATA ---
        // Clean names and specific attributes as requested
        const allCharacters = [
            // MALE
            { file: 'avatars/male/aniol2.png', name: 'Upadły', attribute: 'Moc Światła', gender: 'male' },
            { file: 'avatars/male/druid (2).png', name: 'Druid', attribute: 'Natura', gender: 'male' },
            { file: 'avatars/male/krol.png', name: 'Król', attribute: 'Charyzma', gender: 'male' },
            { file: 'avatars/male/lucznikchlop.png', name: 'Zwiadowca', attribute: 'Zręczność', gender: 'male' },
            { file: 'avatars/male/mag1.png', name: 'Mag', attribute: 'Inteligencja', gender: 'male' },
            { file: 'avatars/male/nekroman1.png', name: 'Nekromanta', attribute: 'Mroczna Magia', gender: 'male' },
            // FEMALE
            { file: 'avatars/female/aniiol1.png', name: 'Anielica', attribute: 'Łaska', gender: 'female' },
            { file: 'avatars/female/druid3.png', name: 'Szamanka', attribute: 'Uzdrawianie', gender: 'female' },
            { file: 'avatars/female/krolowa.png', name: 'Królowa', attribute: 'Władza', gender: 'female' },
            { file: 'avatars/female/lucznikkobieta.png', name: 'Łowczyni', attribute: 'Precyzja', gender: 'female' },
            { file: 'avatars/female/magkobiet.png', name: 'Czarodziejka', attribute: 'Żywioły', gender: 'female' },
            { file: 'avatars/female/nekromanta2.png', name: 'Nekromantka', attribute: 'Klątwy', gender: 'female' }
        ];

        let selectedHero = null;
        let creationName = "";
        let creationGender = "";

        // MISSING KEYS FIX
        const keys = {};

        let playerPos = { x: 15, y: 15 }; // Center of 30x30 map
        const TILE_SIZE = 32;

        // MOVEMENT STATE
        let isMoving = false;
        let lastMoveTime = 0;
        const MOVE_COOLDOWN = 180; // ms

        // --- ARENA STATE ---
        const battleState = {
            active: false,
            units: [],
            currentUnitIndex: 0,
            gridSize: { x: 12, y: 10 },
            tileSize: 64,

            log: (msg) => {
                const log = document.getElementById('battleLog');
                if (log) {
                    log.innerHTML += `<div>> ${msg}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
            },

            endTurn: () => {
                battleState.currentUnitIndex = (battleState.currentUnitIndex + 1) % battleState.units.length;
                battleState.startTurn();
            },

            startTurn: () => {
                if (!battleState.active) return;
                const unit = battleState.units[battleState.currentUnitIndex];
                // simple highlight logic or AI trigger would go here
            }
        };

        // WIZARD LOGIC
        function nextStep(currentStep) {
            if (currentStep === 1) {
                // 1. Name Validation
                const nameInput = document.getElementById('playerNameInput');
                const name = nameInput.value.trim();
                const err = document.getElementById('nameError');

                if (name.length < 3) {
                    err.textContent = "Imię musi mieć min. 3 znaki!";
                    return;
                }
                if (name.length > 15) {
                    err.textContent = "Imię może mieć max. 15 znaków!";
                    return;
                }

                // 2. Gender Validation
                if (!creationGender) {
                    err.textContent = "Wybierz płeć!";
                    return;
                }

                creationName = name;
                err.textContent = "";

                // Go to step 2 (Class Selection)
                document.getElementById('step-name').classList.remove('active');
                document.getElementById('step-class').classList.add('active');

                renderClassSelection();
            }
        }

        function prevStep(currentStep) {
            if (currentStep === 2) {
                document.getElementById('step-class').classList.remove('active');
                document.getElementById('step-name').classList.add('active');
            }
        }

        function selectGender(gender) {
            creationGender = gender;
            // Visual feedback
            document.querySelectorAll('.gender-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${gender}`).classList.add('active');

            checkShowNextBtn();
        }

        function checkShowNextBtn() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            const nextBtn = document.getElementById('nextStepBtn');

            if (name.length >= 3 && creationGender) {
                nextBtn.style.display = 'inline-block';
            } else {
                nextBtn.style.display = 'none';
            }
        }

        // Listen to input changes
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            if (nameInput) {
                nameInput.addEventListener('input', checkShowNextBtn);
            }
        });

        function renderClassSelection() {
            const grid = document.getElementById('charGrid');
            grid.innerHTML = ''; // Clear prev

            // Filter by gender
            const filteredChars = allCharacters.filter(c => c.gender === creationGender);

            filteredChars.forEach((char) => {
                const card = document.createElement('div');
                card.className = 'card';

                card.innerHTML = `
                    <div class="card-image-container">
                        <img src="img/${char.file}" class="card-image" alt="${char.name}">
                    </div>
                    <div class="card-content">
                        <div class="class-name">${char.name}</div>
                        <div class="char-attribute">${char.attribute}</div>
                    </div>
                `;

                card.onclick = () => {
                    document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedHero = char;
                    document.getElementById('playBtn').classList.remove('disabled');
                    document.getElementById('playBtn').classList.add('visible');
                };
                grid.appendChild(card);
            });
        }
        // --- GAME LOGIC ---
        function startGame() {
            if (!selectedHero) return;

            // Transition UI
            document.getElementById('selectScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('active');
            // document.getElementById('attackBtn').style.display = 'flex'; // Deprecated
            // Attack is now turn-based via clicking monsters
            document.getElementById('joystickContainer').style.display = 'block'; // Show joystick

            // Setup HUD
            document.getElementById('hudAvatar').src = `img/${selectedHero.file}`;

            // USE CHOSEN NAME
            document.getElementById('hudName').innerText = creationName.toUpperCase();

            // Save game on start
            saveGame();

            // Update level in HUD
            updateHUDLevel();

            // Spawn World first so player entity exists
            createWorld();

            // Wait for layout to update so updateCamera can read container width/height
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    updatePlayerPosition();
                });
            });

            // Log
            addToChat(`System: Wybrano postać ${selectedHero.name}.`, 'chat-sys');

            // Listeners
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);

            // Start Game Loop
            playerPixelX = playerPos.x * TILE_SIZE; // Initialize pixel position
            playerPixelY = playerPos.y * TILE_SIZE;
            requestAnimationFrame(gameLoop);
        }

        // GAME LOOP for Smooth Movement
        let lastTime = 0;
        function gameLoop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.05); // Cap dt to prevent jumps
            lastTime = timestamp;

            let dx = 0;
            let dy = 0;

            // X axis - separate from Y for 8-way movement
            if (keys['ArrowLeft'] || keys['a']) dx = -1;
            else if (keys['ArrowRight'] || keys['d']) dx = 1;

            // Y axis - separate from X for 8-way movement
            if (keys['ArrowUp'] || keys['w']) dy = -1;
            else if (keys['ArrowDown'] || keys['s']) dy = 1;

            // Normalize diagonal movement (so it's not faster)
            if (dx !== 0 && dy !== 0) {
                const factor = 0.707; // 1/sqrt(2)
                dx *= factor;
                dy *= factor;
            }

            if (!battleState.active && selectedHero) {
                attemptMove(dx, dy, dt); // Always call, even with 0 movement (for camera)
            }

            // Update Animation
            if (window.proceduralPlayer) {
                window.proceduralPlayer.update(dt, dx, dy);
            }

            // Monster AI - attack player if close
            if (typeof updateMonsterAI === 'function') {
                updateMonsterAI();
            }

            requestAnimationFrame(gameLoop);
        }

        // Physics-based smooth movement (like movement_demo.html)
        let playerPixelX = 0;
        let playerPixelY = 0;
        let playerVelX = 0;
        let playerVelY = 0;
        const MOVE_ACCEL = 800;   // Acceleration (pixels/s²)
        const MOVE_FRICTION = 12; // Friction multiplier
        const MOVE_MAX_SPEED = 150; // Max speed (pixels/s)

        function attemptMove(dx, dy, dt) {
            // Apply acceleration based on input
            let accelX = dx * MOVE_ACCEL;
            let accelY = dy * MOVE_ACCEL;

            // Apply friction (slows down when no input)
            let speed = Math.sqrt(playerVelX * playerVelX + playerVelY * playerVelY);
            if (speed > 0.1) {
                let fricX = -playerVelX / speed * MOVE_FRICTION * speed * dt;
                let fricY = -playerVelY / speed * MOVE_FRICTION * speed * dt;

                // Only apply friction if not accelerating in that direction
                if (dx === 0) playerVelX += fricX;
                if (dy === 0) playerVelY += fricY;
            }

            // Apply acceleration
            playerVelX += accelX * dt;
            playerVelY += accelY * dt;

            // Clamp to max speed
            speed = Math.sqrt(playerVelX * playerVelX + playerVelY * playerVelY);
            if (speed > MOVE_MAX_SPEED) {
                playerVelX = (playerVelX / speed) * MOVE_MAX_SPEED;
                playerVelY = (playerVelY / speed) * MOVE_MAX_SPEED;
            }

            // Stop if very slow and no input
            if (speed < 5 && dx === 0 && dy === 0) {
                playerVelX = 0;
                playerVelY = 0;
            }

            // Update position
            playerPixelX += playerVelX * dt;
            playerPixelY += playerVelY * dt;

            // Bounds check (30 tiles * TILE_SIZE)
            const MAX_PX = 30 * TILE_SIZE - TILE_SIZE;
            if (playerPixelX < 0) { playerPixelX = 0; playerVelX = 0; }
            if (playerPixelX > MAX_PX) { playerPixelX = MAX_PX; playerVelX = 0; }
            if (playerPixelY < 0) { playerPixelY = 0; playerVelY = 0; }
            if (playerPixelY > MAX_PX) { playerPixelY = MAX_PX; playerVelY = 0; }

            // Update grid position for z-index and other logic
            playerPos.x = Math.floor(playerPixelX / TILE_SIZE);
            playerPos.y = Math.floor(playerPixelY / TILE_SIZE);

            updatePlayerPosition();
        }



        function createWorld() {
            const world = document.getElementById('worldGrid');

            // Generate Map Tiles
            // Clear world first (except player if reusing)
            world.innerHTML = '';

            const MAP_SIZE = 30; // Reduced from 60 for better performance

            // Resize Map Container
            world.style.width = (MAP_SIZE * TILE_SIZE) + 'px';
            world.style.height = (MAP_SIZE * TILE_SIZE) + 'px';

            world.innerHTML = '';

            // GENERATE VILLAGE DATA
            // 0: Grass, 1: Dirt Path, 2: Stone Floor (Plaza), 3: Wood Floor (House), 4: Wall
            const mapData = new Array(MAP_SIZE).fill(0).map(() => new Array(MAP_SIZE).fill(0));

            const centerX = Math.floor(MAP_SIZE / 2);
            const centerY = Math.floor(MAP_SIZE / 2);

            // 1. Main Roads (Cross)
            for (let i = 0; i < MAP_SIZE; i++) {
                mapData[centerY][i] = 1; // Horizontal
                mapData[centerY + 1][i] = 1;
                mapData[i][centerX] = 1; // Vertical
                mapData[i][centerX + 1] = 1;
            }

            // 2. Central Plaza
            for (let y = centerY - 5; y <= centerY + 6; y++) {
                for (let x = centerX - 5; x <= centerX + 6; x++) {
                    mapData[y][x] = 2;
                }
            }

            // 3. Houses (Randomly placed in quadrants) - adjusted for 30x30 map
            const houses = [
                { x: centerX - 8, y: centerY - 8, w: 5, h: 4 },
                { x: centerX + 4, y: centerY - 6, w: 4, h: 5 },
                { x: centerX - 6, y: centerY + 4, w: 5, h: 4 },
                { x: centerX + 5, y: centerY + 5, w: 4, h: 4 },
            ];

            houses.forEach(h => {
                for (let py = h.y; py < h.y + h.h; py++) {
                    for (let px = h.x; px < h.x + h.w; px++) {
                        // Bounds check
                        if (py < 0 || py >= MAP_SIZE || px < 0 || px >= MAP_SIZE) continue;

                        // Outer Wall
                        if (px === h.x || px === h.x + h.w - 1 || py === h.y || py === h.y + h.h - 1) {
                            if (px !== h.x + Math.floor(h.w / 2) && py !== h.y + h.h) // Door logic simplified
                                mapData[py][px] = 4; // Wall
                        } else {
                            mapData[py][px] = 3; // Floor
                        }
                    }
                }
                // Door - with bounds check
                const doorY = h.y + h.h - 1;
                const doorX = h.x + Math.floor(h.w / 2);
                if (doorY >= 0 && doorY < MAP_SIZE && doorX >= 0 && doorX < MAP_SIZE) {
                    mapData[doorY][doorX] = 3;
                }
            });


            // RENDER MAP (OSM/SVG Style)
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile-svg-container';
                    tile.style.position = 'absolute';
                    tile.style.left = (x * TILE_SIZE) + 'px';
                    tile.style.top = (y * TILE_SIZE) + 'px';
                    tile.style.width = TILE_SIZE + 'px';
                    tile.style.height = TILE_SIZE + 'px';

                    const type = mapData[y][x];
                    let fillColor = '#4a9c4a'; // Brighter grass
                    let strokeColor = '#5cb85c';
                    let detail = '';

                    if (type === 0) { // Grass - vibrant green
                        fillColor = '#4a9c4a';
                        strokeColor = '#5cb85c';
                        if (Math.random() > 0.7) fillColor = '#3d8b3d'; // Variation
                        if (Math.random() > 0.95) detail = `<circle cx="16" cy="16" r="3" fill="#6bc96b" />`; // Flower
                        if (Math.random() > 0.9) detail = `<path d="M14,22 L16,12 L18,22" stroke="#2d6b2d" fill="none" stroke-width="2"/>`; // Grass blade
                    } else if (type === 1) { // Dirt Path - golden brown
                        fillColor = '#c4a35a';
                        strokeColor = '#b08d40';
                        detail = `<rect x="8" y="8" width="4" height="4" fill="#9a7a3a" rx="1"/>`;
                    } else if (type === 2) { // Plaza Stone - light gray
                        fillColor = '#888';
                        strokeColor = '#999';
                        detail = `<rect x="1" y="1" width="30" height="30" fill="none" stroke="#666" stroke-width="2" rx="2"/>`;
                    } else if (type === 3) { // Wood Floor - warm brown
                        fillColor = '#8b6914';
                        strokeColor = '#7a5c12';
                        detail = `<line x1="0" y1="8" x2="32" y2="8" stroke="#6b5210" stroke-width="1"/><line x1="0" y1="16" x2="32" y2="16" stroke="#6b5210" stroke-width="1"/><line x1="0" y1="24" x2="32" y2="24" stroke="#6b5210" stroke-width="1"/>`;
                    } else if (type === 4) { // Wall - dark stone
                        fillColor = '#555';
                        strokeColor = '#333';
                        detail = `<rect x="0" y="0" width="32" height="32" fill="#444" /><rect x="3" y="3" width="26" height="26" fill="#666" /><rect x="6" y="6" width="20" height="20" fill="#555" />`;
                    }

                    tile.innerHTML = `
                        <svg width="${TILE_SIZE}" height="${TILE_SIZE}" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                            <rect x="0" y="0" width="32" height="32" fill="${fillColor}" stroke="${strokeColor}" stroke-opacity="0.2" />
                            ${detail}
                        </svg>
                    `;

                    world.appendChild(tile);
                }
            }

            // Add Player Entity (CANVAS)
            const playerContainer = document.createElement('div');
            playerContainer.id = 'playerEntity';
            playerContainer.className = 'entity player-token';
            // Remove static IMG logic
            playerContainer.style.zIndex = Math.floor(playerPos.x + playerPos.y + 1);
            playerContainer.style.width = '32px';
            playerContainer.style.height = '32px';
            playerContainer.style.marginLeft = '-16px'; // Center horizontally
            playerContainer.style.marginTop = '-22px'; // Offset to place feet on tile
            playerContainer.style.transform = `translate3d(0, 0, 10px) rotateX(-60deg) scale(0.7)`;

            // Initialize Procedural Player
            window.proceduralPlayer = new ProceduralPlayer(playerContainer);

            world.appendChild(playerContainer);

            // Spawn monsters with custom images
            const beast1 = createMonster(18, 14, 'Bestia', 50, 'monsters/bestaia1.png');
            monsters.push(beast1);
            spawnMonster(world, beast1);

            const beast2 = createMonster(20, 18, 'Bestia', 50, 'monsters/bestia2.png');
            monsters.push(beast2);
            spawnMonster(world, beast2);

            const beast3 = createMonster(12, 20, 'Bestia', 40, 'monsters/bestaia1.png');
            monsters.push(beast3);
            spawnMonster(world, beast3);


        }

        function spawnEntity(parent, x, y, icon) {
            const el = document.createElement('div');
            el.className = 'entity npc';
            el.innerHTML = icon;
            el.style.left = (x * TILE_SIZE) + 'px';
            el.style.top = (y * TILE_SIZE) + 'px';
            // Simple depth sorting
            el.style.zIndex = Math.floor(x + y);

            // Make enemies interactable
            if (icon === '🐀' || icon === '🕷️') {
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'pointer';
                el.onclick = () => startBattle(icon === '🐀' ? 'Przerośnięty Szczur' : 'Wielki Pająk', icon);
            }

            parent.appendChild(el);
        }

        // --- ARENA LOGIC ---
        function startBattle(enemyName, enemyIcon) {
            battleState.active = true;
            document.getElementById('arenaScreen').classList.add('active');

            // Setup Arena Grid
            const grid = document.getElementById('arenaGrid');
            grid.innerHTML = '';
            for (let y = 0; y < battleState.gridSize.y; y++) {
                for (let x = 0; x < battleState.gridSize.x; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'arena-tile';
                    tile.style.left = (x * battleState.tileSize) + 'px';
                    tile.style.top = (y * battleState.tileSize) + 'px';
                    tile.dataset.x = x;
                    tile.dataset.y = y;
                    tile.onclick = () => handleArenaClick(x, y);
                    grid.appendChild(tile);
                }
            }

            // Create Units (Adjust for new grid size)
            // Random monster
            const monsterImg = Math.random() > 0.5 ? 'monsters/bestaia1.png' : 'monsters/bestia2.png';

            battleState.units = [
                { name: selectedHero.name, icon: `img/${selectedHero.file}`, maxHp: 100, hp: 100, x: 1, y: 4, isPlayer: true, id: 'hero' },
                { name: enemyName, icon: `img/${monsterImg}`, maxHp: enemyName === 'Boss' ? 200 : 50, hp: enemyName === 'Boss' ? 200 : 50, x: 10, y: 4, isPlayer: false, id: 'enemy' }
            ];

            // Render Units
            battleState.units.forEach(u => spawnArenaUnit(u));

            battleState.currentUnitIndex = 0;
            battleState.startTurn();
        }

        function spawnArenaUnit(unit) {
            const el = document.createElement('div');
            el.className = `arena-unit ${unit.isPlayer ? 'hero' : 'enemy'}`;
            el.id = `unit-${unit.id}`;

            let visual = '';
            if (unit.icon) visual = `<img src="${unit.icon}">`;
            else visual = `<div style="font-size:50px">${unit.iconHtml}</div>`;

            el.innerHTML = `
                <div class="arena-unit-hp"><div class="arena-unit-hp-fill" style="width:${(unit.hp / unit.maxHp) * 100}%"></div></div>
                ${visual}
            `;
            updateArenaUnitPos(el, unit.x, unit.y);
            document.getElementById('arenaGrid').appendChild(el);
        }

        function updateArenaUnitPos(el, x, y) {
            el.style.left = (x * battleState.tileSize + battleState.tileSize / 2) + 'px';
            el.style.top = (y * battleState.tileSize + battleState.tileSize / 2) + 'px';
            el.style.zIndex = x + y + 10;
        }

        function highlightUnit(unit) {
            // Simple visual cue for now
            document.querySelectorAll('.arena-unit').forEach(u => u.style.filter = 'brightness(0.6)');
            document.getElementById(`unit-${unit.id}`).style.filter = 'brightness(1.2) drop-shadow(0 0 10px gold)';
        }

        function handleArenaClick(x, y) {
            const currentUnit = battleState.units[battleState.currentUnitIndex];
            if (!currentUnit.isPlayer) return; // Wait for AI

            // Simple movement logic
            const dx = Math.abs(x - currentUnit.x);
            const dy = Math.abs(y - currentUnit.y);

            // Allow move to adjacent
            if (dx <= 1 && dy <= 1 && (dx + dy) > 0) {
                // Check if occupied
                const target = battleState.units.find(u => u.x === x && u.y === y);
                if (target) {
                    // Combat Logic - Damage Variation
                    const dmg = Math.floor(Math.random() * 10) + 10; // 10-20 dmg

                    battleState.log(`${currentUnit.name} atakuje ${target.name} za ${dmg}!`);
                    showFloatingText(target.x, target.y, `-${dmg}`, 'red');

                    target.hp -= dmg;
                    updateUnitVisuals(target);

                    if (target.hp <= 0) {
                        battleState.log(`${target.name} pokonany!`);
                        showFloatingText(target.x, target.y, '☠', 'darkred');
                        setTimeout(() => {
                            document.getElementById('arenaScreen').classList.remove('active');
                            battleState.active = false;
                        }, 1500);
                    }
                } else {
                    // Move
                    currentUnit.x = x;
                    currentUnit.y = y;
                    updateArenaUnitPos(document.getElementById(`unit-${currentUnit.id}`), x, y);
                }
                battleState.endTurn();
            }
        }

        function updateUnitVisuals(unit) {
            const el = document.getElementById(`unit-${unit.id}`);
            el.querySelector('.arena-unit-hp-fill').style.width = (unit.hp / unit.maxHp) * 100 + '%';
        }

        function aiTurn() {
            const ai = battleState.units[battleState.currentUnitIndex];
            const target = battleState.units.find(u => u.isPlayer);

            if (!target || target.hp <= 0) { battleState.endTurn(); return; }

            // Simple Chase
            const dx = target.x - ai.x;
            const dy = target.y - ai.y;

            // Try to move closer
            let moveX = ai.x;
            let moveY = ai.y;

            if (Math.abs(dx) > Math.abs(dy)) {
                moveX += Math.sign(dx);
            } else {
                moveY += Math.sign(dy);
            }

            // Interaction Check
            if (moveX === target.x && moveY === target.y) {
                // Attack Player
                const dmg = Math.floor(Math.random() * 5) + 5; // 5-10 dmg
                battleState.log(`${ai.name} gryzie ${target.name} za ${dmg}!`);
                showFloatingText(target.x, target.y, `-${dmg}`, 'red');

                target.hp -= dmg;
                updateUnitVisuals(target);
                if (target.hp <= 0) {
                    battleState.log(`${target.name} padł! KONIEC GRY.`);
                    setTimeout(() => location.reload(), 2000); // Reset for demo
                }
            } else {
                // Check if tile free
                const occupied = battleState.units.find(u => u.x === moveX && u.y === moveY);
                if (!occupied) {
                    ai.x = moveX;
                    ai.y = moveY;
                    updateArenaUnitPos(document.getElementById(`unit-${ai.id}`), moveX, moveY);
                }
            }

            battleState.endTurn();
        }

        function showFloatingText(x, y, text, color) {
            const grid = document.getElementById('arenaGrid');
            const el = document.createElement('div');
            el.innerText = text;
            el.style.position = 'absolute';
            el.style.left = (x * battleState.tileSize + 30) + 'px';
            el.style.top = (y * battleState.tileSize) + 'px';
            el.style.color = color || 'white';
            el.style.fontSize = '24px';
            el.style.fontWeight = 'bold';
            el.style.textShadow = '0 0 5px black';
            el.style.zIndex = 1000;
            el.style.animation = 'floatUp 1s ease-out forwards';
            el.style.pointerEvents = 'none';
            // Simple transition
            el.style.transition = 'all 1s';
            setTimeout(() => { el.style.top = (y * battleState.tileSize - 50) + 'px'; el.style.opacity = 0; }, 50);

            grid.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updatePlayerPosition() {
            // W tym trybie (Kamery za graczem) nie przesuwamy gracza na ekranie!
            // Gracz zawsze zostaje na środku (w sensie logicznym), a przesuwamy MAPĘ.
            // Ale dla zachowania hierarchii DOM, player jest w worldGrid.
            // Używamy PIKSELI dla płynnego ruchu!

            const player = document.getElementById('playerEntity');
            if (player) {
                player.style.left = playerPixelX + 'px';  // PIXEL position, not tile!
                player.style.top = playerPixelY + 'px';
                player.style.zIndex = Math.floor(playerPos.x + playerPos.y + 1);
            }
            updateCamera();
        }

        function updateCamera() {
            const world = document.getElementById('worldGrid');
            const container = document.querySelector('.game-map-container');

            // Środek ekranu
            const cx = container.offsetWidth / 2;
            const cy = container.offsetHeight / 2;

            // Pozycja gracza w świecie (w pikselach) - używamy PIXEL position!
            // Dodajemy TILE_SIZE/2 żeby celować w środek kafelka
            const px = playerPixelX + (TILE_SIZE / 2);
            const py = playerPixelY + (TILE_SIZE / 2);

            // Przesuwamy świat tak, by gracz był w cx, cy
            // world left = cx - px
            // world top = cy - py
            // Pamiętamy o rotateX(65deg)
            // Transform: translation musi być zaaplikowane do kontenera lub do transformation matrix.
            // Najprościej: przesunąć worldGrid metodą translate3d w jego lokalnym układzie? Nie, to przesunie go w 3D po pochyleniu.
            // Musimy przesunąć 'left' i 'top' diva #worldGrid, albo użyć translate przed rotacją.

            // W CSS mamy: transform: rotateX(65deg);
            // Zmieńmy to na dynamiczne:

            // worldGrid jest absolute. Zmieniajmy jego left/top.
            // Defaultowo jest left: 50%, top: 25% co ustala "Anchor" transformacji.
            // Aby "kamera" śledziła, musimy przesuwać worldGrid w PRZECIWNĄ stronę niż ruch gracza.
            // Jeśli gracz idzie w prawo (x+), worldGrid musi iść w lewo (x-).

            // UWAGA: rotacja X jest "w miejscu". Przesuwanie left/top działa w przestrzeni ekranu (Screen Space).
            // A my chcemy przesuwać mapę w jej własnej płaszczyźnie (World Space)?
            // Jeśli przesuniemy left/top, to cała pochylona płaszczyzna się przesunie.
            // To zadziała, pod warunkiem, że przesunięcie w dół (Y) uwzględni skrót perspektywiczny?
            // Nie, rotateX(65deg) skraca wizualnie Y.
            // Jeśli przesuniemy worldGrid o 10px w dół (screen Y), to wizualnie przesunie się o 10px.
            // Ale w świecie gry 10px "po podłodze" to mniej pikseli na ekranie (cos(65)).
            // NIEPRAWDĘ mówię. Jeśli element jest obrócony, to jego osie lokalne też.
            // Użyjmy transformacji w kolejności: translate(moveWorld) -> rotateX.

            // Resetujemy defaultowe left/top z CSS
            world.style.left = '0';
            world.style.top = '0';
            world.style.marginLeft = '0';

            // CRITICAL: Set transform origin to 0 0 so our translations work as expected relative to top-left
            world.style.transformOrigin = '0 0';

            world.style.transform = `
                translate3d(${cx}px, ${cy}px, 0) 
                scale(3.5)
                rotateX(60deg) 
                translate3d(${-px}px, ${-py}px, 0)
            `;
        }


        // Old handleInput removed in favor of gameLoop


        function addToChat(msg, type = 'chat-msg') {
            // Chat removed, but keeping function to prevent errors if called
            // console.log(msg); 
        }

        window.addEventListener('resize', () => {
            if (selectedHero) updateCamera();
        });

        function toggleMenu() {
            const overlay = document.getElementById('overlay');
            const joystick = document.getElementById('joystickContainer');

            if (overlay.style.display === 'flex') {
                overlay.style.display = 'none';
                if (joystick) joystick.style.display = 'block';
            } else {
                overlay.style.display = 'flex';
                if (joystick) joystick.style.display = 'none';
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function toggleModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal.classList.contains('active')) {
                modal.classList.remove('active');
            } else {
                // Close others first
                document.querySelectorAll('.mobile-modal').forEach(m => m.classList.remove('active'));
                modal.classList.add('active');
            }
        }

        // Mobile Controls handlers
        document.querySelectorAll('.dpad-btn').forEach(btn => {
            const key = btn.dataset.key;

            const startMove = (e) => {
                e.preventDefault(); // Prevent scroll
                if (keys[key]) return; // Already pressed
                keys[key] = true;
                btn.classList.add('active');
                if (!isMoving) requestAnimationFrame(gameLoop);
            };

            const endMove = (e) => {
                if (e.cancelable) e.preventDefault();
                keys[key] = false;
                btn.classList.remove('active');
            };

            // --- PROCEDURAL PLAYER ---
            class ProceduralPlayer {
                constructor(container) {
                    this.canvas = document.createElement('canvas');
                    this.canvas.width = 120; // High res for small size
                    this.canvas.height = 120;
                    this.canvas.style.width = '100%';
                    this.canvas.style.height = '100%';
                    container.appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    // State matching the prototype
                    this.animTime = 0;
                    this.idleTime = 0;
                    this.facing = 0; // 0:Front, 1:Back, 2:Right, 3:Left
                    this.isMoving = false;
                    this.bodyRotation = 0;
                    this.turnFactor = 1;
                    this.velMag = 0;
                }

                update(dt, inputDx, inputDy) {
                    // Determine facing based on input
                    let targetRot = 0;
                    let targetTurn = 1;

                    if (inputDx !== 0 || inputDy !== 0) {
                        this.isMoving = true;
                        this.velMag = 15; // Simulated speed for anim

                        if (inputDy < 0) this.facing = 1; // Up -> Back
                        else if (inputDy > 0) this.facing = 0; // Down -> Front
                        if (inputDx > 0) this.facing = 2; // Right
                        else if (inputDx < 0) this.facing = 3; // Left
                    } else {
                        this.isMoving = false;
                        this.velMag = 0;
                    }

                    if (this.facing === 2) targetRot = 1;
                    else if (this.facing === 3) targetRot = -1;

                    if (this.facing === 1) targetTurn = -1; // Back
                    else if (this.facing === 0) targetTurn = 1; // Front
                    if (this.facing === 2 || this.facing === 3) targetTurn = 0;

                    // Smooth transitions
                    this.bodyRotation += (targetRot - this.bodyRotation) * 10 * dt;
                    this.turnFactor += (targetTurn - this.turnFactor) * 8 * dt;

                    if (this.isMoving) {
                        this.animTime += dt * 5; // Run speed
                        this.idleTime = 0;
                    } else {
                        this.animTime = 0;
                        this.idleTime += dt * 2;
                    }

                    this.draw();
                }

                draw() {
                    const ctx = this.ctx;
                    const W = this.canvas.width;
                    const H = this.canvas.height;
                    const CX = W / 2;
                    const GROUND_Y = H - 20;

                    ctx.clearRect(0, 0, W, H);

                    // Colors
                    const C = {
                        SKIN: '#ffdbac',
                        SKIN_SHADOW: '#e0b080',
                        SHIRT: '#29b6f6',
                        PANTS: '#263238',
                        SHOES: '#212121',
                        HAIR: '#3e2723' // Dark Brown
                    };

                    let bob = this.isMoving ? Math.abs(Math.sin(this.animTime)) * 3 : Math.sin(this.idleTime) * 1.5;
                    let hipY = GROUND_Y - 35 - bob; // Raised hips
                    let legStartY = hipY + 12;

                    // Shadow
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.beginPath();
                    ctx.ellipse(CX, GROUND_Y, 14, 5, 0, 0, Math.PI * 2);
                    ctx.fill();

                    let isFacingRight = (this.facing === 2);
                    let isFacingLeft = (this.facing === 3);
                    let isSideView = (isFacingRight || isFacingLeft);
                    // logic for "visual back" based on transition value
                    let visualIsBack = this.turnFactor < -0.2;

                    let rot = this.bodyRotation;

                    const drawLeg = (isLeft) => {
                        let phase = isLeft ? 0 : Math.PI;
                        let hipOffset = isLeft ? -7 : 7;
                        hipOffset *= (1 - Math.abs(rot) * 0.8);

                        let swing = Math.cos(this.animTime + phase);
                        if (isSideView) swing *= -1;

                        let lift = Math.max(0, Math.sin(this.animTime + phase)) * 10;
                        if (!this.isMoving) { swing = 0; lift = 0; }

                        let hipX = CX + hipOffset;
                        let stride = 14;

                        let stepX = 0;
                        if (isFacingRight) stepX = swing * stride;
                        else if (isFacingLeft) stepX = swing * -stride;

                        let footX = hipX + stepX;
                        let footY = GROUND_Y - lift; // Simplified Z-height

                        let kneeX = (hipX + footX) / 2 + (stepX * 0.2);
                        let kneeY = (legStartY + footY) / 2;

                        ctx.lineWidth = 8;
                        ctx.strokeStyle = C.PANTS;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(hipX, legStartY);
                        ctx.quadraticCurveTo(kneeX, kneeY, footX, footY);
                        ctx.stroke();

                        ctx.fillStyle = C.SHOES;
                        ctx.beginPath();
                        ctx.ellipse(footX, footY, 6, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    const drawArm = (isLeft) => {
                        let shoulderX = CX + (isLeft ? -13 : 13) * (1 - Math.abs(rot) * 0.6);
                        let shoulderY = hipY - 24;
                        let phase = isLeft ? Math.PI : 0;

                        let handX = shoulderX;
                        let handY = shoulderY + 25;

                        if (this.isMoving) {
                            let swing = Math.cos(this.animTime + phase) * 15;
                            if (isSideView) handX += swing;
                            else handY -= Math.abs(swing) * 0.5;
                        } else {
                            handX += Math.sin(this.idleTime) * 2;
                        }

                        ctx.strokeStyle = C.SHIRT;
                        ctx.lineWidth = 7;
                        ctx.beginPath();
                        ctx.moveTo(shoulderX, shoulderY);
                        ctx.lineTo(handX, handY);
                        ctx.stroke();

                        ctx.fillStyle = C.SKIN;
                        ctx.beginPath();
                        ctx.arc(handX, handY, 4, 0, Math.PI * 2);
                        ctx.fill();
                    };

                    // Draw Order
                    if (visualIsBack) {
                        drawLeg(true); drawLeg(false);
                        drawArm(true); drawArm(false);
                    } else {
                        drawLeg(true); drawLeg(false); // Front legs
                    }

                    // TORSO
                    ctx.fillStyle = C.SHIRT;
                    ctx.beginPath();
                    let w = 14 - Math.abs(rot) * 5;
                    ctx.moveTo(CX - w, hipY - 28); // Shoulders
                    ctx.lineTo(CX + w, hipY - 28);
                    ctx.lineTo(CX + w - 2, hipY + 10);
                    ctx.lineTo(CX - w + 2, hipY + 10);
                    ctx.fill();

                    if (!visualIsBack) {
                        drawArm(true); drawArm(false);
                    }

                    // HEAD
                    let headY = hipY - 42;
                    let headX = CX + rot * 4;

                    // Neck
                    ctx.fillStyle = C.SKIN_SHADOW;
                    ctx.fillRect(headX - 4, headY + 12, 8, 8);

                    // Face
                    ctx.fillStyle = C.SKIN;
                    ctx.beginPath();
                    ctx.arc(headX, headY, 13, 0, Math.PI * 2);
                    ctx.fill();

                    // EYES - FIX: Only draw if NOT back
                    if (!visualIsBack) {
                        let eyeOff = rot * 8;
                        ctx.fillStyle = '#111';

                        if (isSideView) {
                            ctx.beginPath(); ctx.arc(headX + (isFacingRight ? 5 : -5), headY, 2, 0, Math.PI * 2); ctx.fill();
                        } else {
                            ctx.beginPath(); ctx.arc(headX - 4, headY, 2, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(headX + 4, headY, 2, 0, Math.PI * 2); ctx.fill();
                        }
                    }

                    // HAIR - FIX: Improved style
                    ctx.fillStyle = C.HAIR;
                    ctx.beginPath();
                    // Base
                    ctx.arc(headX, headY - 2, 14, 0, Math.PI * 2); // Bigger volume
                    // Spikes / Messy top
                    ctx.moveTo(headX - 14, headY - 5);
                    ctx.quadraticCurveTo(headX, headY - 20, headX + 14, headY - 5);

                    // Back cover if facing back
                    if (visualIsBack) {
                        ctx.lineTo(headX + 14, headY + 8);
                        ctx.quadraticCurveTo(headX, headY + 15, headX - 14, headY + 8);
                    } else {
                        // Front bangs
                        ctx.lineTo(headX + 14, headY + 2);
                        ctx.quadraticCurveTo(headX, headY - 5, headX - 14, headY + 2);
                    }
                    ctx.fill();
                }
            }

            // Mouse
            btn.addEventListener('mousedown', startMove);
            btn.addEventListener('mouseup', endMove);
            btn.addEventListener('mouseleave', endMove);

            // Touch
            btn.addEventListener('touchstart', (e) => startMove(e), { passive: false });
            btn.addEventListener('touchend', (e) => endMove(e), { passive: false });
            btn.addEventListener('touchcancel', (e) => endMove(e), { passive: false });
        });

        // VIRTUAL JOYSTICK
        let joystickActive = false;
        let joystickDx = 0;
        let joystickDy = 0;

        function setupJoystick() {
            const container = document.getElementById('joystickContainer');
            const base = document.getElementById('joystickBase');
            const knob = document.getElementById('joystickKnob');
            if (!base || !knob) return;

            const maxDist = 35;

            const handleMove = (clientX, clientY) => {
                const rect = base.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }

                knob.style.left = `calc(50% + ${dx}px)`;
                knob.style.top = `calc(50% + ${dy}px)`;

                // Normalize to -1 to 1
                joystickDx = dx / maxDist;
                joystickDy = dy / maxDist;

                // Dead zone
                if (Math.abs(joystickDx) < 0.2) joystickDx = 0;
                if (Math.abs(joystickDy) < 0.2) joystickDy = 0;

                // Set virtual keys for gameLoop
                keys['ArrowLeft'] = joystickDx < -0.3;
                keys['ArrowRight'] = joystickDx > 0.3;
                keys['ArrowUp'] = joystickDy < -0.3;
                keys['ArrowDown'] = joystickDy > 0.3;
            };

            const handleEnd = () => {
                joystickActive = false;
                knob.style.left = '50%';
                knob.style.top = '50%';
                knob.style.transform = 'translate(-50%, -50%)';
                joystickDx = 0;
                joystickDy = 0;
                keys['ArrowLeft'] = false;
                keys['ArrowRight'] = false;
                keys['ArrowUp'] = false;
                keys['ArrowDown'] = false;
            };

            base.addEventListener('mousedown', (e) => {
                joystickActive = true;
                handleMove(e.clientX, e.clientY);
            });

            base.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });

            window.addEventListener('mousemove', (e) => {
                if (joystickActive) handleMove(e.clientX, e.clientY);
            });

            window.addEventListener('touchmove', (e) => {
                if (joystickActive) handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });

            window.addEventListener('mouseup', handleEnd);
            window.addEventListener('touchend', handleEnd);
        }

        setupJoystick();

        // IRATUS-STYLE TURN COMBAT SYSTEM
        let playerHP = 100;
        let playerMana = 50;
        let playerLevel = 1;
        let playerXP = 0;
        let playerGold = 0;
        let monstersKilled = 0;
        let currentCombat = null;
        let playerTurn = true;
        let isDefending = false;

        // XP thresholds for each level (first kill = instant level 2)
        const XP_THRESHOLDS = [0, 0, 100, 250, 500, 800, 1200, 1700, 2300, 3000, 4000];

        function getXPForNextLevel(level) {
            return XP_THRESHOLDS[level + 1] || (level * 500);
        }

        function calculateXPGain(monsterLevel) {
            return 50 + (monsterLevel * 20) + Math.floor(Math.random() * 30);
        }

        function addXP(amount) {
            if (playerLevel === 1 && monstersKilled === 0) {
                // First kill - instant level 2!
                playerLevel = 2;
                playerXP = 0;
                showGameMessage('⬆️ LEVEL UP! Poziom 2!', 'success');
                updateHUDLevel();
                saveGame();
                return;
            }

            playerXP += amount;
            const needed = getXPForNextLevel(playerLevel);

            while (playerXP >= needed && playerLevel < 99) {
                playerXP -= needed;
                playerLevel++;
                showGameMessage(`⬆️ LEVEL UP! Poziom ${playerLevel}!`, 'success');
            }
            updateHUDLevel();
            saveGame();
        }

        function updateHUDLevel() {
            const levelEl = document.getElementById('hudLevel');
            if (levelEl) levelEl.textContent = 'Lv.' + playerLevel;

            const xpEl = document.getElementById('hudXP');
            if (xpEl) {
                const needed = getXPForNextLevel(playerLevel);
                xpEl.textContent = playerXP + '/' + needed + ' XP';
            }
        }

        // SAVE/LOAD GAME
        function saveGame() {
            const saveData = {
                heroFile: selectedHero ? selectedHero.file : null,
                heroName: selectedHero ? selectedHero.name : null,
                playerName: creationName,
                level: playerLevel,
                xp: playerXP,
                hp: playerHP,
                mana: playerMana,
                gold: playerGold,
                monstersKilled: monstersKilled
            };
            localStorage.setItem('bestia_save', JSON.stringify(saveData));
        }

        function loadGame() {
            const data = localStorage.getItem('bestia_save');
            if (!data) return false;

            try {
                const save = JSON.parse(data);
                if (save.heroFile && save.playerName) {
                    // Find hero by file
                    selectedHero = allCharacters.find(h => h.file === save.heroFile) || null;
                    creationName = save.playerName || '';
                    playerLevel = save.level || 1;
                    playerXP = save.xp || 0;
                    playerHP = save.hp || 100;
                    playerMana = save.mana || 50;
                    playerGold = save.gold || 0;
                    monstersKilled = save.monstersKilled || 0;
                    return true;
                }
            } catch (e) {
                console.error('Failed to load save:', e);
            }
            return false;
        }

        function resetGame() {
            localStorage.removeItem('bestia_save');
            selectedHero = null;
            creationName = '';
            playerLevel = 1;
            playerXP = 0;
            playerHP = 100;
            playerMana = 50;
            playerGold = 0;
            monstersKilled = 0;
            location.reload();
        }

        function startCombat(monster) {
            currentCombat = {
                monster: monster,
                playerHP: playerHP,
                playerMaxHP: 100,
                // Add Mana to combat state
                playerMana: playerMana,
                playerMaxMana: 50,

                enemyHP: monster.hp,
                enemyMaxHP: monster.maxHp,
                enemyName: monster.name
            };

            // Setup combat screen
            document.getElementById('combatScreen').classList.add('active');

            // Player Info
            document.getElementById('playerCombatName').textContent = selectedHero ? selectedHero.name.toUpperCase() : 'GRACZ';
            document.getElementById('playerCombatLevel').textContent = 'Lvl 1'; // Placeholder for now

            // Enemy Info
            document.getElementById('enemyCombatName').textContent = monster.name.toUpperCase();
            document.getElementById('enemyCombatLevel').textContent = 'Lvl ' + (monster.level || 1);

            // Set Player Sprite (Image)
            const playerSprite = document.getElementById('playerCombatSprite');
            if (selectedHero && selectedHero.file) {
                playerSprite.innerHTML = `<img src="img/${selectedHero.file}" style="width:100px;height:100px;object-fit:contain;">`;
                // Remove any emoji text content if present, just in case
                // logic handled by innerHTML replacement
            } else {
                playerSprite.textContent = '🧙';
            }

            // Set Enemy Sprite
            const enemySprite = document.getElementById('enemyCombatSprite');
            if (monster.visual.includes('.png') || monster.visual.includes('.jpg')) {
                enemySprite.innerHTML = `<img src="img/${monster.visual}" style="width:80px;height:80px;object-fit:contain;">`;
            } else {
                enemySprite.textContent = monster.visual;
            }

            // Update HP displays
            updateCombatHP();

            playerTurn = true;
            isDefending = false;
            document.getElementById('turnIndicator').textContent = 'TWOJA TURA';
            document.getElementById('combatLog').innerHTML = `> Walka z ${monster.name} rozpoczęta!`;
            setButtonsEnabled(true);
        }

        function updateCombatHP() {
            const c = currentCombat;
            document.getElementById('playerCombatHP').style.width = (c.playerHP / c.playerMaxHP * 100) + '%';
            document.getElementById('playerHPText').textContent = `${Math.max(0, c.playerHP)}/${c.playerMaxHP}`;

            // Mana Update
            document.getElementById('playerCombatMana').style.width = (playerMana / c.playerMaxMana * 100) + '%';
            document.getElementById('playerManaText').textContent = `${Math.max(0, playerMana)}/${c.playerMaxMana}`;

            document.getElementById('enemyCombatHP').style.width = (c.enemyHP / c.enemyMaxHP * 100) + '%';
            document.getElementById('enemyHPText').textContent = `${Math.max(0, c.enemyHP)}/${c.enemyMaxHP}`;
        }

        function setButtonsEnabled(enabled) {
            document.querySelectorAll('.combat-btn').forEach(btn => {
                btn.disabled = !enabled;
            });
        }

        function addCombatLog(msg) {
            const log = document.getElementById('combatLog');
            log.innerHTML += `<br>> ${msg}`;
            log.scrollTop = log.scrollHeight;
        }

        function combatSkill(skillName) {
            if (!playerTurn || !currentCombat) return;

            let damage = 0;
            let manaCost = 0;
            let healAmount = 0;
            let logMsg = '';
            let animationClass = 'attacking';

            // Skill Logic
            if (skillName === 'attack') {
                manaCost = 0;
                damage = 8 + Math.floor(Math.random() * 8); // 8-15 dmg
                logMsg = `Szybki atak! Zadajesz ${damage} obrażeń.`;
            } else if (skillName === 'fireball') {
                manaCost = 20;
                if (playerMana < manaCost) {
                    addCombatLog('Za mało many! (Potrzeba 20)');
                    return;
                }
                damage = 25 + Math.floor(Math.random() * 15); // 25-40 dmg
                logMsg = `Kula ognia! Zadajesz ${damage} obrażeń! 🔥`;
                animationClass = 'attacking'; // Could add specific magic anim
            } else if (skillName === 'heal') {
                manaCost = 15;
                if (playerMana < manaCost) {
                    addCombatLog('Za mało many! (Potrzeba 15)');
                    return;
                }
                healAmount = 30;
                logMsg = `Leczenie! Odzyskujesz ${healAmount} HP. ❤️`;
                animationClass = ''; // No attack anim
            }

            // Pay Mana
            if (manaCost > 0) {
                playerMana -= manaCost;
            }

            setButtonsEnabled(false);

            // Execute Effects
            if (damage > 0) {
                // Player attack animation
                const playerSprite = document.getElementById('playerCombatSprite');
                playerSprite.classList.add(animationClass);
                setTimeout(() => playerSprite.classList.remove(animationClass), 300);

                currentCombat.enemyHP -= damage;

                // Enemy hit animation
                setTimeout(() => {
                    const enemySprite = document.getElementById('enemyCombatSprite');
                    enemySprite.classList.add('hit');
                    setTimeout(() => enemySprite.classList.remove('hit'), 300);
                }, 150);
            }

            if (healAmount > 0) {
                currentCombat.playerHP = Math.min(currentCombat.playerMaxHP, currentCombat.playerHP + healAmount);
                const playerSprite = document.getElementById('playerCombatSprite');
                playerSprite.classList.add('hit'); // reused for visual feedback
                setTimeout(() => playerSprite.classList.remove('hit'), 300);
            }

            addCombatLog(logMsg);
            updateCombatHP();

            // Check enemy death
            if (currentCombat.enemyHP <= 0) {
                setTimeout(() => endCombat(true), 500);
                return;
            }

            // Enemy turn
            setTimeout(enemyTurn, 800);
        }

        // function combatAttack() REMOVED in favor of combatSkill('attack')

        function combatDefend() {
            if (!playerTurn || !currentCombat) return;
            setButtonsEnabled(false);
            isDefending = true;
            addCombatLog('Przygotwujesz się do obrony!');
            document.getElementById('turnIndicator').textContent = 'OBRONA!';

            setTimeout(enemyTurn, 500);
        }

        function combatFlee() {
            if (!playerTurn || !currentCombat) return;

            // 50% chance to flee
            if (Math.random() > 0.5) {
                addCombatLog('Udało Ci się uciec!');
                setTimeout(() => endCombat(null), 500);
            } else {
                addCombatLog('Nie udało się uciec!');
                setButtonsEnabled(false);
                setTimeout(enemyTurn, 500);
            }
        }

        function enemyTurn() {
            playerTurn = false;
            document.getElementById('turnIndicator').textContent = 'TURA WROGA';

            setTimeout(() => {
                // Enemy attack animation
                const enemySprite = document.getElementById('enemyCombatSprite');
                enemySprite.classList.add('attacking');
                setTimeout(() => enemySprite.classList.remove('attacking'), 300);

                // Calculate damage (reduced if defending)
                let damage = 5 + Math.floor(Math.random() * 10);
                if (isDefending) {
                    damage = Math.floor(damage * 0.3);
                    addCombatLog(`Blokowałeś! Tylko ${damage} obrażeń!`);
                } else {
                    addCombatLog(`${currentCombat.enemyName} zadaje ${damage} obrażeń!`);
                }

                currentCombat.playerHP -= damage;
                playerHP = currentCombat.playerHP;

                // Player hit animation
                setTimeout(() => {
                    const playerSprite = document.getElementById('playerCombatSprite');
                    playerSprite.classList.add('hit');
                    setTimeout(() => playerSprite.classList.remove('hit'), 300);
                }, 150);

                updateCombatHP();
                isDefending = false;

                // Check player death
                if (currentCombat.playerHP <= 0) {
                    setTimeout(() => endCombat(false), 500);
                    return;
                }

                // Back to player turn
                setTimeout(() => {
                    playerTurn = true;
                    document.getElementById('turnIndicator').textContent = 'TWOJA TURA';
                    setButtonsEnabled(true);
                }, 500);
            }, 500);
        }

        function endCombat(playerWon) {
            document.getElementById('combatScreen').classList.remove('active');

            if (playerWon === true) {
                // Victory!
                const monsterLevel = currentCombat.monster.level || 1;
                const xpGain = calculateXPGain(monsterLevel);
                const goldGain = 10 + Math.floor(Math.random() * 20);

                monstersKilled++;
                playerGold += goldGain;

                showGameMessage(`🎉 Wygrałeś walkę!\n+${xpGain} XP  +${goldGain} 💰`, 'success');

                // Add XP (handles leveling)
                addXP(xpGain);

                // Remove monster from map
                const m = currentCombat.monster;
                const idx = monsters.indexOf(m);
                if (idx > -1) {
                    if (m.element) m.element.remove();
                    monsters.splice(idx, 1);
                }

                // Update gold in HUD
                const goldEl = document.getElementById('goldText');
                if (goldEl) goldEl.textContent = playerGold;
            } else if (playerWon === false) {
                // Defeat
                showGameMessage('💀 Przegrałeś walkę!', 'error');
                playerHP = 100;
            }
            // else: fled, no changes except HP

            // Update HUD HP
            const hpFill = document.querySelector('.hp-fill');
            const hpText = document.getElementById('hpText');
            if (hpFill) hpFill.style.width = playerHP + '%';
            if (hpText) hpText.textContent = playerHP + '/100';

            currentCombat = null;
        }

        // Custom in-game message (replaces alert to prevent fullscreen exit)
        function showGameMessage(text, type = 'info') {
            const overlay = document.createElement('div');
            overlay.className = 'game-message-overlay';
            overlay.innerHTML = `
                <div class="game-message ${type}">
                    <div class="game-message-text">${text}</div>
                    <button class="game-message-btn" onclick="this.parentElement.parentElement.remove()">OK</button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (overlay.parentElement) overlay.remove();
            }, 3000);
        }

        // Settings Menu
        function showSettingsMenu() {
            const overlay = document.createElement('div');
            overlay.className = 'game-message-overlay';
            overlay.id = 'settingsOverlay';
            overlay.innerHTML = `
                <div class="game-message" style="min-width: 300px;">
                    <div class="game-message-text">⚙️ Ustawienia</div>
                    <div style="display:flex; flex-direction:column; gap:10px; margin-bottom:20px;">
                        <button class="game-message-btn" onclick="toggleFullscreen(); document.getElementById('settingsOverlay').remove();">📺 Pełny Ekran</button>
                        <button class="game-message-btn" style="background: linear-gradient(135deg, #f44336, #d32f2f);" onclick="confirmResetGame()">🗑️ Resetuj Postać</button>
                    </div>
                    <button class="game-message-btn" onclick="document.getElementById('settingsOverlay').remove()">❌ Zamknij</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        function confirmResetGame() {
            const overlay = document.createElement('div');
            overlay.className = 'game-message-overlay';
            overlay.id = 'confirmResetOverlay';
            overlay.innerHTML = `
                <div class="game-message error">
                    <div class="game-message-text">⚠️ Na pewno resetować?<br><small style="font-size:0.8rem;">Utracisz postać, poziom i postępy!</small></div>
                    <div style="display:flex; gap:10px; justify-content:center;">
                        <button class="game-message-btn" style="background: linear-gradient(135deg, #f44336, #d32f2f);" onclick="resetGame()">TAK, RESETUJ</button>
                        <button class="game-message-btn" onclick="document.getElementById('confirmResetOverlay').remove();">NIE</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
        }

        // Make monsters clickable for combat
        function makeMonsterClickable(monsterElement, monster) {
            monsterElement.style.cursor = 'pointer';
            monsterElement.addEventListener('click', () => {
                // Check if close enough (2 tiles)
                const mx = monster.x + 12;
                const my = monster.y + 12;
                const dist = Math.sqrt((playerPixelX - mx) ** 2 + (playerPixelY - my) ** 2);

                if (dist < TILE_SIZE * 2.5) {
                    startCombat(monster);
                } else {
                    showFloatingDamage(playerPixelX, playerPixelY - 20, 'Za daleko!', '#ffff00');
                }
            });
        }

        // Override spawnMonster to make monsters clickable
        const originalSpawnMonster = spawnMonster;
        spawnMonster = function (world, monster) {
            originalSpawnMonster(world, monster);
            makeMonsterClickable(monster.element, monster);
        };

        // FULLSCREEN TOGGLE
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen error:', err);
                    });
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        }

        // Alias for menu
        function toggleFullScreen() {
            toggleFullscreen();
        }

        // Auto-fullscreen on first interaction (mobile)
        let hasRequestedFullscreen = false;
        function requestFullscreenOnce() {
            if (hasRequestedFullscreen) return;
            hasRequestedFullscreen = true;

            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => { });
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            }

            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => { });
            }
        }

        document.addEventListener('click', requestFullscreenOnce, { once: true });
        // Removed touchstart to prevent "API can only be initiated by a user gesture" errors on scroll
        // document.addEventListener('touchstart', requestFullscreenOnce, { once: true });

        document.addEventListener('fullscreenchange', () => {
            const btn = document.querySelector('.fullscreen-hint');
            if (btn) {
                btn.style.display = document.fullscreenElement ? 'none' : 'block';
            }
        });

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            const installBtn = document.getElementById('installBtn');
            if (installBtn) installBtn.style.display = 'inline-block';
        });

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('PWA installed');
                    }
                    deferredPrompt = null;
                    document.getElementById('installBtn').style.display = 'none';
                });
            } else {
                alert('Dodaj grę do ekranu głównego:\n\nAndroid: Menu ⋮ → "Zainstaluj aplikację"\niOS: Share → "Dodaj do ekranu początkowego"');
            }
        }

        // Try to lock screen to landscape
        function tryLockLandscape() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape')
                    .then(() => console.log('Locked to landscape'))
                    .catch(() => alert('Blokada orientacji nie jest obsługiwana.\nSpróbuj włączyć pełny ekran lub zainstalować jako PWA.'));
            } else {
                alert('Blokada orientacji nie jest obsługiwana w tej przeglądarce.\n\niOS: Dodaj do ekranu głównego jako aplikację.');
            }
        }

        // AUTO-LOAD SAVED GAME ON STARTUP
        (function initGame() {
            // Fix layout on load
            fixIOSLayout();
            window.addEventListener('resize', fixIOSLayout);
            window.addEventListener('orientationchange', () => {
                setTimeout(fixIOSLayout, 100);
            });

            if (loadGame()) {
                // Found saved game - auto start!
                console.log('Loaded saved game:', creationName, selectedHero?.name);

                // Fill in the name input if it exists
                const nameInput = document.getElementById('heroNameInput');
                if (nameInput) nameInput.value = creationName;

                // Wait a moment for DOM to be ready, then start game
                setTimeout(() => {
                    startGame();
                }, 100);
            }
        })();

        // AGGRESSIVE iOS LAYOUT FIX
        function fixIOSLayout() {
            const height = window.innerHeight;
            document.documentElement.style.height = height + 'px';
            document.body.style.height = height + 'px';

            const combatScreen = document.getElementById('combatScreen');
            if (combatScreen) {
                combatScreen.style.height = height + 'px';
                // Force bottom padding regarding safe area manually if needed
                // But mostly ensuring the container fits the visible window is key
            }
        }
    </script>
</body>

</html>